#+TITLE: Clase 06 - Indices - Subqueries - Union/Intersect

#+BEGIN_COMMENT
leadtime es el tiempo promedio de entrega que tiene el proveedor
y se utiliza para los sistemas q usan intime
#+END_COMMENT

* Pila de Dudas (?)
  Ordenadas por prioridad
  1. [[DUDA 4]] (pag. 11 pdf=30-DML...)
  2. [[DUDA 5]] (pag. 12, pdf=30-DML...)
  3. [[DUDA 1]]
  4. [[DUDA 2]]
  5. [[DUDA 3]]
  6. DUDA 6: Pag. 27,28, pdf=30-DML.. no hace falta un ~DISTINCT~ en el SELECT?
* DDL y DML
** Conceptos
   Recordemos que *DDL* se refiere al conjunto de operaciones de un lenguaje que permiten
   definir estructuras. (/Ej. CREATE TABLE, ALTER TABLE, .../)

   Mientras que *DML* al conjunto de operaciones que permiten manipular los datos
   (/Ej. SELECT, UPDATE, DELETE, .../)
** DDL - Data Definition Language
   De lo visto en esta clase, entraría en el DDL
   + Indices
** DML - Data Manipulation Language
   De lo visto en esta clase, entraría en el DML
   + Subqueries
   + Operadores Multi-Select (UNION, INTERSECT, EXCEPT)
* [DOING] Indices
** Conceptos
  + Son _estructuras opcionales a las tablas_
  + Son _físicamente independientes_ de los datos a la tabla asociada
    (por tanto el borrar los índices, no afecta a las tablas que estén asociadas)
  + Para _acceder más rápido a las tablas_
  + Se pueden crear sobre uno (simple) ó varios campos (compuesto)
  + Ayuda a la *integridad* y *unicidad*
** [TODO] Tipos de Indices
*** Conceptos
    La diferencia entre ellos es la estructura en como se guardan
*** Btree Index
    Es el más utilizada (para índices relacionales)
    
    <<DUDA 1>>: mongodb lo usa dijo en clase ? me suena raro porque no es no-relacional?
*** Btree +
*** Btree Cluster Index
    - _Ordena fisicamente la tabla_ (los datos) en el momento que se crea
    - Solo puede haber 1 por tabla

    <<DUDA 2>>: También ordena el índice??
*** Bitmap Index (Oracle)
    + Arma un mapa de bit
    + Cada *bit* en el *bitmap* representa una fila (con valor 0 ó 1)
*** Hash Index (Mysql)
    + Están implementados en *tablas de hash*
    + Se basan en otros índices *Btree*
    + Es la _manera más rápida de ejecutar consultas a una tabla, si está cargada en memoria_
    <<DUDA 3>>: En una clase posterior habia mencionado algo más acerca
    cuando las tablas se cargan en memoria?
*** Functional Index / function based index
    La *clave* de estos indices, derivan del resultado de una *función*
    (suelen ser _funciones que son definidas por el usuario_)  
*** Reverse key index (Oracle)
    + Invierte los *bytes* de la clave a indexar
** [TODO] Características diferenciadoras
*** Conceptos
    - Cuando dice *filas*, se refiere a la fila de la estructura de índices,
      no de la tabla asociada
    - Cuando menciona *clave* se refiere a la clave del índice, porque este
      está formado por una relación de *clave-valor*
*** Único
    Una sola fila por clave (es decir único)
*** Duplicado
    Muchas filas asociadas a la misma clave
*** Simple
    Clave formada _por una columna_
*** Compuesto
    Clave formada _por varias columnas_ (Ej. dni y tipo de documento)
** Beneficios de su uso
   - Mejor perfomance en el acceso y en el ordenamiento
   - Nos evita tener que ordenarlos (/ya los deja ordenados cuando se crean/)
   - Es una *búsqueda n-aria*, por tanto más potente que una *búsqueda binaria*
   - Se evita realizar *lecturas secuenciales*, se accede a través de los índices
   - Cuando usemos los ~JOIN~ será más eficiente (/nested join, join con indices/)
** Desventajas
   - Costo de espacio en disco
     (/puede que el espacio ocupado por los índices sea mayor que los datos de tabla asociada/)
   - Costo de procesamiento y mantenimiento
     (/porque tiene que actualizar e insertar en varias partes/)

   *Observación:*
   El índice se bloquea cada vez que una fila es actualizada/insertada/borrada
   para que el sistema pueda recorrer/actualizar los índices
** Algoritmos - Complejidad
    |-------------+--------------------------------|
    | Complejidad | Algoritmo                      |
    |-------------+--------------------------------|
    | Secuencial  | NxN elementos                  |
    |             |                                |
    | Binarias    | N x log(n+1) con log en base 2 |
    |             |                                |
    | Btree       | N x log(n+1) con log en base N |
    |-------------+--------------------------------|
** Cuando deberiamos Indexar
   Indexeamos Columnas en las que frecuentemente
   + Asociamos tablas con ~JOIN~
   + Hay filtros aplicados con ~WHERE~
   + Ordenamos con ~ORDER BY~
** [TODO] Precauciones al Indexar
   + Que el tamaño del índice sea menor comparado con la fila
     - Crear índices en columnas donde la longitud del atributo sea chico
       (/ya sean letras o números, aplica en cualquiera de los casos/)
   + Limitar la cantidad de indices en tablas
     (/por el tema de los costos de espacio y de procesamiento/)

   #+BEGIN_COMMENT
   _RESPUESTA:_
   si tiene pocas filas va a acceder rápido igual
   el motor no trabaja con bytes, si no con páginas

   <<DUDA 4>>
   Cómo es el tema de crear indices con poca cant. de filas,
   por lo de la cant de páginas? (pag. 11, 30-DML..pdf)
  
   El apunte dice:
   No crear índices sobre tablas con poca cantidad de filas, no olvidar que
   siempre se recupera de a páginas. De esta manera evitaríamos que el sistema
   lea el árbol de índices
   #+END_COMMENT

   #+BEGIN_QUOTE
   Se tiende a decir que los índices formados con una clave numérica son más eficientes que aquellos
   formados por letras. La realidad es que NO importa si es un número ó una letra.
   Lo que importa es que la longitud de la clave sea mínima, por tanto puede ser alfanumérica.
   #+END_QUOTE
** [TODO] Recomendaciones al Indexar
   + Si usamos *Indices Compuestos* incrementamos los valores únicos
   + Si utilizamos *Cluster Index* se agiliza la recuperacion de filas, porque
     - su objetivo es _reducir la entrada/salida de disco_
     - las filas se guardan en Bloques Contiguos permitiendo
       1. facilitar el acceso
       2. reduci la cant. de accesos (/porque se recuperan en menos páginas los mismos datos/)

     #+BEGIN_COMMENT
     <<DUDA 5>>
     Como sería lo de *Búsqueda de clave parcial* ? (pag. 12, 30-DML..pdf)
    
     El apunte dice:
     Tratar de usar índices compuestos para incrementar los valores únicos
     Tener en cuenta que si una o más columnas intervienen en un índice
     compuesto el optimizador podría decidir acceder a través de ese índice
     aunque sea solo para la búsqueda de los datos de una columna, esto se
     denomina “partial key search
     #+END_COMMENT
** [TODO] Construccion de Indices en Paralelo
   - Se sugiere _migrar sin los índices_ y luego recrearlos

   #+BEGIN_EXAMPLE
   El Btree + se construye a partir de 2 o más pocesos paralelos. 
   #+END_EXAMPLE
** Implementación de Indices
   Estas implementaciones son para el *motor sql server*

   #+BEGIN_SRC sql
     -- indice único y simple
     CREATE UNIQUE index ix1_ordenes ON ordenes (n_orden);

     -- índice duplicado y compuesto
     CREATE UNIQUE index ix2_ordenes ON ordenes (cliente, n_orden);

     -- índice clustered
     CREATE CLUSTERED index ix3_ordenes ON ordenes (n_orden);
   #+END_SRC
** [TODO] Manejo de Load Factor - Fill Factor 
   El ~fillfactor~ es el porcentaje de cada página del índice a ser dejado
   como espacio libre en su creación. 
   Si no utilizamos el ~fillfactor~, las páginas de los datos de los índices
   se llenan completamente

   #+BEGIN_EXAMPLE
   Si el fillfactor=20, cuando se cree el índice, este ocupará hasta el 80%
   de cada nodo y un 20% quedará libre
   #+END_EXAMPLE

   #+BEGIN_SRC sql
     CREATE UNIQUE INDEX i_ordenes ON ordenes(n_orden)
       WITH FILLFACTOR=20;
   #+END_SRC
** IOT - Tablas organizadas por índice (Oracle)
  - También se conocen por *index organized table
* [TODO] Subqueries
** Conceptos
   Primero se ejecutan las *subqueries* y luego la *query principal*
** SubQuery en UPDATE
*** Conceptos
   Las subqueries en la operación ~UPDATE~ se pueden colocar en
   1. En la clausula ~SET~ quedando ~SET columna=subquery_aca~
   2. En la clausula ~WHERE~ 
      1. devolviendo un valor escalar ~WHERE columna = subquery_aca~
      2. ó devolviendo múltiples filas ~WHERE columna (IN/NOT IN) subquery_aca~
      3. ó cuando se evalúa una condición en general ~WHERE (EXISTS/NOT EXISTS) subquery_aca~

   *Observaciones:*
   - Si usamos ~=/IN/NOT IN~ debemos indicar previamente la columna
   - Si usamos ~EXISTS/NOT EXISTS~ NO indicamos la columna quedando ~WHERE EXISTS subquery~ 
     ó ~WHERE NOT EXISTS subquery~ 
   - Para ambos casos _podemos usar ~JOIN~ en vez de Subqueries_ y viceversa
*** Ejemplo genérico
    #+BEGIN_SRC sql
      UPDATE FROM nombreTabla
         SET nombreColumna = subquery1
       WHERE nombreColumna (=/IN/NOT IN) subquery2
             (EXISTS/NOT EXISTS) subquery3;
    #+END_SRC
*** Ejemplo 1
    #+BEGIN_SRC sql
      UPDATE #clientesParaBorrar
         SET state = (SELECT state FROM state WHERE sname='florida')
       WHERE customer_num=101;

      -- esto va a FALLAR..!
      -- PROBLEMA: La subquery devuelve varios resultados, en vez de sólo uno
      -- SOLUCION: Usar IN en vez del =
      UPDATE manufact lead_time=15
       WHERE manu_code =(SELECT DISTINCT manu_code FROM items);
    #+END_SRC
** SubQuery en el SELECT
*** Conceptos
   Las subqueries en la operación ~SELECT~ se pueden colocar en
   1. En la lista de columnas ~SELECT col1, col2, subquery_aca~
   2. En el FROM quedando ~FROM nombreTabla JOIN subquery_aca~
   2. En la clausula ~WHERE~ con los mismos 3 escenarios que sucedían en el ~UPDATE~
*** Ejemplo genérico
    #+BEGIN_SRC sql
      SELECT col1, col2, subquery1
        FROM nombreTabla JOIN subquery2
       WHERE nombreColumna (=/<=/>=/IN/NOT IN) subquery3
             (EXISTS/NOT EXISTS) subquery4
       GROUP BY ...
      HAVING funcionAgregada (=/<=/>=/IN/NOT IN) subquery5
             (EXISTS/NOT EXISTS) subquery6
       ORDER BY subquery7;
    #+END_SRC
*** Ejemplo 1 - Usando alias
    Una subquery que devuelve un conjunto de filas se le puede asignar un *alias*
    como si fuese una tabla más, quedando algo como ~subquery as c~ (se puede omitir el ~as~)

    #+BEGIN_SRC sql
      -- Vemos como la subquery devuelve un conjunto de filas
      -- y se le da el alias "c2" que luego se usa para el JOIN
      SELECT nombre,apellido FROM clientes c1
         JOIN (SELECT cod_cliente cliente, count(orden_num) cantidad
               FROM pedidos GROUP BY cod_cliente) c2 /* acá le asigna el alias a la subquery */
         ON (c1.cod_cliente=c2.cod_cliente);
    #+END_SRC
*** Ejemplo 2 - Devuelve multiples filas
   #+BEGIN_SRC sql
     SELECT lname+','+fname, customer_num FROM customer
      WHERE customer_num IN (
        SELECT customer_num FROM cust_calls
         GROUP BY customer_num HAVING count(*)>1
      );

     -- es la misma query pero con JOINS
     SELECT lname+', '+fname, c.customer_num
       FROM customer c
       JOIN cust_calls cc ON cc.customer_num = c.customer_num
      GROUP BY c.customer_num, lname, fname
     HAVING count(cc.customer_num)>1;
   #+END_SRC
*** Ejemplo 3 - Devuelve un valor escalar
    Recordemos que si usamos en la cláusula ~WHERE~ el símbolo = (igual) 
    es porque vamos a comparar un único valor, es decir un escalar.
   
    *Observación:*
    Sería un ERROR si usamos el = y la subconsulta devolviese múltiples filas.

   #+BEGIN_SRC sql
     select count(*) from customer c1 where
     city=(select city from customer where lname='Higgins')

     -- es la misma query pero con JOINS
     select count(*) from customer c1
     JOIN customer c2 on c1.city=c2.city
     where c2.lname='Higgins';
   #+END_SRC
** Subquery en el DELETE
*** Conceptos
   Las subqueries en la operación ~DELETE~ se pueden colocar en
   1. En la cláusula ~WHERE~ con los mismos 3 escenarios que sucedían en el ~UPDATE~

   *Observación:*
   Se pueden agrupar las *subqueries* utilizando el operador lógico ~AND~
   quedando algo como ~WHERE cod_client NOT IN subquery AND cod_cliente NOT IN subquery2...~
*** Ejemplo genérico
    #+BEGIN_SRC sql
      DELETE FROM tabla
       WHERE nombreColumna NOT IN subquery1
         AND nombreColumna NOT IN subquery2
         AND nombreColumna NOT IN subquery3;
    #+END_SRC
*** Ejemplo 2
    #+BEGIN_SRC sql
      -- Creamos una tabla temporal de forma "implícita"
      -- usando los datos de la tabla customer
      SELECT * INTO #clientesParaBorrar FROM customer;

      -- para luego poder probar esta query con subqueries
      -- y no afectar la tabla real
      DELETE FROM #clientesParaBorrar
       WHERE customer_num NOT IN (SELECT DISTINCT customer_num FROM cust_calls)
         AND customer_num NOT IN (SELECT DISTINCT customer_num FROM orders)
         AND customer_num NOT IN (
           SELECT DISTINCT customer_num_referedBy FROM customer c2
            WHERE customer_num_referedBy IS NOT NULL
         );
    #+END_SRC
** Subquery Correlacionado
*** Conceptos
    Es una *subconsulta* que utiliza valores de la *consulta principal* en  su cláusula ~WHERE~
*** Ejemplo 1
    #+BEGIN_SRC sql
      SELECT customer_num, lname FROM customer c
       WHERE NOT EXISTS (
         SELECT order_num FROM orders o
          -- esta condición del where indica que es una "subconsulta correlacionada"
          -- porque utiliza columnas de la "consulta principal" para comparar
          WHERE o.customer_num = c.customer_num
       );
    #+END_SRC
*** Ejemplo 2
   #+BEGIN_SRC sql
     /*
      ,* Ingreso de Multiples registros
      ,* - En esta query existe un gran nivel de "acoplamiento" (por usar el * asterisco)
      ,*/
     INSERT INTO closed_orders
     SELECT * FROM orders -- Ojo..! EVITEMOS el * asterisco, a futuro GENERA PROBLEMAS
      WHERE paid_date IS NOT NULL;

     -- la columna cantidad viene de la subquery, es un campo calculado
     SELECT lname, fname nombre, cliente, cantidad
     FROM  customer c1 JOIN
     -- esta es la subquery correlacionada
     -- (porque utiliza una columna de la query principal)
     (SELECT customer_num cliente, count(order_num) cantidad
     FROM orders GROUP BY customer_num) c2
     ON c1.customer_num = c2.cliente;
   #+END_SRC
* Operadores Multi-Select
** Operador UNION
*** Conceptos
   - La tabla resultante adquiere los nombres de las columnas del primer ~SELECT~
   - Devuelve las filas del primer ~SELECT~ y del segundo ~SELECT~
   - Trae la unión de ambas consultas pero _NO repite los datos_
     (a menos que usemos ~union all~, similar a un distinct)

   *Observaciones:*
   1. La _cantidad de columnas_ y los _tipos de datos_ de los ~SELECT~ deben ser iguales
   2. Sólo se puede _ordenar indicando la posición de las columnas_ en el ~ORDER BY~
*** Ejemplo 1
   #+BEGIN_SRC sql
     -- El resultado será una tabla nueva, con el nombre de las columnas del primer SELECT
     SELECT cod_producto, precio -- las columnas de los SELECT deben ser las mismas (1)
       FROM productos
      WHERE precio < 10
      UNION -- << ACA ESTÁ EL UNION >>
     SELECT cod_producto, precio  -- las columnas de los SELECT deben ser las mismas (1)
       FROM items
      WHERE cod_prod = 10
      ORDER BY 1, 2; -- solo se puede ordenar con la posición de las columnas (2)
   #+END_SRC
*** Ejemplo 2 - Elegir el orden de los resultados
    Podemos agregar una columna extra para ordenarlos, usando un número entero y agregandole un ~alias~
    (Ej. ~SELECT 1 orden, nombre, apellido~)

    En este ejemplo a la primera columna de cada ~SELECT~ le pusimos un número entero y le pusimos de alias ~orden~
    luego en el ~ORDER BY~ indicamos que ordene por la nueva columna (que tiene posición 1).
    Además aplicamos un filtro diferente para cada una en el ~WHERE~
    El resultado final sería
    1. muestra los registros que tengan precio igual a 10
    2. luego los registros que tenga precio mayor a 50
    3. por último los registros que tengan precio entre 15 y 20

    Recordemos que dice ~ORDER BY 1 ASC~ ordenará de manera ascendente 1,2,3,4,..
    usando de referencia los valores que tenga la primera columna

   #+BEGIN_SRC sql
     SELECT 1 orden, cod_producto, precio -- las columnas de los SELECT deben ser las mismas (1)
       FROM productos WHERE precio = 10
     UNION -- << UNION >>
     SELECT 3 orden, cod_producto, precio -- las columnas de los SELECT deben ser las mismas (1)
       FROM productos WHERE precio BETWEEN 15 AND 20
     UNION -- << UNION >>
     SELECT 2 orden, cod_producto, precio -- las columnas de los SELECT deben ser las mismas (1)
       FROM productos WHERE precio > 50
      ORDER BY 1 ASC, 2 DESC; -- solo se puede ordenar con la posición de las columnas (2)
   #+END_SRC
** Operador UNION ALL
*** Conceptos
   + Tiene las mismas restricciones que el ~UNION~ para los ~SELECT~
     1. Misma cantidad de columnas
     2. Mismo tipos de datos
     3. Ordenar por posición de columna
   + NO hace el ~DISTINCT~, por tanto _repite filas_
*** Ejemplos
   #+BEGIN_SRC sql
     -- El resultado será una tabla nueva, con el nombre de las columnas del primer SELECT
     SELECT cod_producto, precio -- las columnas de los SELECT deben ser las mismas (1)
       FROM productos
      WHERE precio < 10
      UNION ALL -- << ACA ESTÁ EL UNION ALL>>
     SELECT cod_producto, precio  -- las columnas de los SELECT deben ser las mismas (1)
       FROM items
      WHERE cod_prod = 10
      ORDER BY 1, 2; -- solo se puede ordenar con la posición de las columnas (2)
   #+END_SRC
** Operador INTERSECT
*** Conceptos
   + Devuelve las filas que están en ambas consultas
   + Tiene las mismas restricciones que el ~UNION~ para los ~SELECT~
     1. Misma cantidad de columnas
     2. Mismo tipos de datos
     3. Ordenar por posición de columna
*** Ejemplos
   #+BEGIN_SRC sql
     -- El resultado será una tabla nueva, con el nombre de las columnas del primer SELECT
     SELECT cod_producto, precio -- las columnas de los SELECT deben ser las mismas (1)
       FROM productos
      WHERE precio < 10
      INTERSECT -- << ACA ESTÁ EL INTERSECT>>
     SELECT cod_producto, precio  -- las columnas de los SELECT deben ser las mismas (1)
       FROM items
      WHERE cod_prod = 10
      ORDER BY 1, 2; -- solo se puede ordenar con la posición de las columnas (2)
   #+END_SRC
** Operador EXCEPT
*** Conceptos
   + Actúa como la operación *diferencia* de *teoría de conjuntos* 
     (/Ej.Si decimos A-B, es lo mismo que decir todos los elementos de A menos los de B/)
   + Tiene las mismas restricciones que el ~UNION~ para los ~SELECT~
     1. Misma cantidad de columnas
     2. Mismo tipos de datos
     3. Ordenar por posición de columna
*** Ejemplos
   #+BEGIN_SRC sql
     -- seleccionamos los clientes de la tabla "customer"
     -- y que NO estén en la tabla temporal #clientesParaBorrar
     SELECT customer_num FROM customer
     EXCEPT
     SELECT customer_num FROM #clientesParaBorrar;
   #+END_SRC
* Parte práctica en clase
** Ejercicio 1
  #+BEGIN_SRC sql
    SELECT m.manu_code, m.manu_name, lead_time, SUM(quantity*unit_price) AS monto_total
    FROM manufact m LEFT JOIN items i ON m.manu_code = i.manu_code
    GROUP BY m.manu_name, m.manu_code, lead_time
    ORDER BY m.manu_name
  #+END_SRC
** Ejercicio 2
  #+BEGIN_SRC sql
    select s1.stock_num, tp.description, s1.manu_code, s2.manu_Code
    from products s1
    left join products s2 on (s1.stock_num=s2.stock_num AND s1.manu_code != s2.manu_code)
    join product_types tp on (s1.stock_num=tp.stock_num)
    order by 1;

    -- duda q dieron en clase
    select s1.stock_num, tp.description, s1.manu_code, s2.manu_Code
    from products s1
    left join products s2 on (s1.stock_num=s2.stock_num AND s1.manu_code != s2.manu_code)
    join product_types tp on (s1.stock_num=tp.stock_num)
    -- si no le agregamos el "IS NULL" nos estaria sacando fabricantes
    --where s1.manu_code < s2.manu_code OR s2.manu_code IS NULL
    -- El COALESE  reemplaza los NULL por la cadena q pongamos
    where s1.manu_code < COALESE(s2.manu_code, 'ZZZ')
    order by 1;
  #+END_SRC
** Ejercicio 3
  #+BEGIN_SRC sql
    SELECT customer_num, fname, lname, company, address1, address2, city,
    state, zipcode, phone, status
    FROM customer
    WHERE customer_num IN (SELECT customer_num FROM orders
    GROUP BY customer_num HAVING COUNT(order_num)>1)

    -- alternativa (1)
    SELECT customer_num, fname, lname, company, address1, address2, city,
    state, zipcode, phone, status
    FROM customer
    WHERE EXISTS (SELECT customer_num FROM orders WHERE o.customer_num = c.customer_num
    GROUP BY customer_num HAVING COUNT(order_num)>1)

    -- alternativa (2)
    select customer_num, fname, lanem
    from custoer c
    where (select count(order_num) from orders o where o.customer_num=c.customer_num) >1
  #+END_SRC
** Ejercicio 4
  #+BEGIN_SRC sql
    select c.customer_nu, fname, lname
    from customer c join orders o on (c.customer_num=o.customer_num)
    group by c.customer_num, fname, lname
    having counter(order_num)>1
  #+END_SRC
