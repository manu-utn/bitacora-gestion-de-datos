#+TITLE: Clase 08 - Stores Procedures - Funciones - Cursores
* Diccionario de datos
  En ...
  - sys.procedures
    son
  - sys.all_sql_models
    paa ver el codigo de los procedures
* Asignación de valor a Variables
** Conceptos
  - Se asigna el valor de derecha a izquieda
  - Se puede usar ~SET~ ó ~SELECT~

  Los *operadores de asignación compuesta* figuran en esta tabla

  #+name: operadores-asignacion-compuesta
  |----------+-------------------------|
  | Operador | Descripción             |
  |----------+-------------------------|
  | +=       | Sumar y asignar         |
  | -=       | Restar y asignar        |
  | *=       | Multiplicar y asignar   |
  | /=       | Dividir y asignar       |
  | %=       | Módulo y asignar        |
  | &=       | AND bit a bit y asignar |
  | ^=       | XOR bit a bit y asignar |
  |----------+-------------------------|
  
** Ejemplos
*** Ejemplo 1 - Declarar variables
   #+BEGIN_SRC sql
     SET @variable1 = valor

     SELECT @variable2 = valor;
   #+END_SRC
*** Ejemplo 2 - Asignarle el resultado de una consulta a una variable
    Al asignar el resultado de una consulta a una variable, la podemos reutilizar fuera de esta.
    Es útil para cuando se utilizan *cursores*

   #+BEGIN_SRC sql
     SELECT @variable = nombre
       FROM clientes WHERE codCliente = 500;

     SELECT @telefono = tel
       FROM clientes WHERE codCliente = 500;
   #+END_SRC
* Throw - Lanzar Excepciones
** Try y Catch
*** Conceptos
   - Dentro del bloque de ~TRY~ se agregan las sentencias que pueden lanzar alguna excepción/error
   - Dentro del bloque de ~CATCH~ agregamos las sentencias a ejecutar en caso de haber eror en el ~TRY~

   #+BEGIN_SRC sql
     BEGIN TRY
       -- sentencias sql
     END TRY
     BEGIN CATCH
       -- sentencias sql
     END CATCH
   #+END_SRC
*** Ejemplo
  #+BEGIN_SRC sql
    CREATE tabla(
      numero INT PRIMARY KEY
    );

    BEGIN try
      BEGIN tan
      INSERT INTO tabla VALUES (1)
      INSERT INTO tabla VALUES (1)
      COMMIT tran
    END try

    BEGIN catch
      print 'error no se pueden repetir las PK'
      ROLLBACK tran
    END catch
  #+END_SRC
** Throw
  - El ~throw 50099~ es el normal para manejar en programas
  - Cuando la excepcioń es ~level 16~ se detiene toda ejecucion
** Raiserror
  - NO se recomienda utilizar el ~RAISE~ para capturar excepciones
  - Se puede usar para notificar WARNINGS

  #+BEGIN_SRC sql
    RAISERROR('error catch', 16, 1);

    -- El 2do parámetro: es el nivel de error
    -- El 3ro parámetro: es el estado
    -- El mensaje que devuelve es el 5000
    -- OJO..! NO CAPTURA EL ERROR, SIGUE EJECUTANDO EL RESTO DE LAS SENTENCIAS...
  #+END_SRC
* Sentencias condicionales
** Sentencia IF
*** Conceptos
  #+BEGIN_EXAMPLE
    IF condicion
        sentencia 1
    ELSE
        sentencia 2
  #+END_EXAMPLE
*** Ejemplo 1 - Sentencia Simple
  #+BEGIN_SRC sql
    IF (@var1 > 5)
       PRINT 'Hola'
    ELSE
       PRINT 'olis'
  #+END_SRC
*** Ejemplo 2 - Consultas como expresiones
  #+BEGIN_SRC sql
    DECLARE @cod_cliente INT;
    SET @cod_cliente = 199;

    IF EXISTS(SELECT nombre FROM clientes WHERE cod_cliente=@cod_cliente)
       PRINT 'Este cliente existe..! :o'
    ELSE
       PRINT 'El cliente no existe, que pasó acá? Agregalo!'
  #+END_SRC
** Sentencia CASE 
*** Conceptos
    Se puede utilizar en
    + En la instrucción ~SELECT~
      1) Dentro de la cláusula ~SELECT~  (esto sería en donde van la lista de columnas)
      2) Dentro de la cláusula ~ORDER BY~ 
      3) Dentro de la cláusula ~HAVING~
    + En la instrucción ~UPDATE~
    + En la instrucción ~SET~
*** Ejemplo 1 - En la cláusula SELECT de un SELECT
    Lo colocamos en la cláusula ~SELECT~ (que es donde se listan las columnas a seleccionar)
    de la instrucción ~SELECT~.

    #+BEGIN_EXAMPLE
    La sintáxis para este caso sería

    un_alias=CASE nombre_columna
      WHEN valor1_de_la_columna THEN nuevo_valor_de_columna
      WHEN valor2_de_la_columna THEN otro_valor_de_columna
    END
    
    un_alias: es el nombre que aparecerá en el resultado de la consulta,
    nombre_columna: es el nombre real de la columna que queremos usar
    valor_de_columna: es el valor que la columna
    nuevo_valor_de_columna: por el que vamos a reemplazar el que viene como dato
    #+END_EXAMPLE

    #+BEGIN_SRC sql
      SELECT 'Fabricante'=CASE cod_fabricante
        WHEN 'HRO' THEN 'HERO'
        WHEN 'HSK' THEN 'HUSKY'
        ELSE 'OTRO'
        END,
        precio, descripcion FROM dbo.productos
      GO
    #+END_SRC
*** Ejemplo 2 - En la cláusula SELECT como condicional tipo IF
    Igual que el ejemplo anterior, pero podemos agregarle que condiciones
    debería cumplir.
    Además podemos usarlo como columna para ordenar el resultado final.

    #+BEGIN_SRC sql
      SELECT cod_producto, cod_fabricante,
        'Criterio Precio' =
           CASE
             WHEN precio = 0 THEN  'SIN PRECIO'
             WHEN precio < 50 THEN 'SAFA'
             WHEN precio < 100 THEN 'ESTAFA'
             WHEN precio BETWEEN 150 AND 200 THEN 'NI LOCO'
             ELSE 'NI MIRO'
             END
        FROM dbo.productos
       ORDER BY 'Criterio Precio', cod_producto
      GO
    #+END_SRC
*** Ejemplo 4 - En la cláusula ORDER BY con 1 criterio de ordenamiento
    Si usamos la sintáxis de los anteriores ~case~ sólo podríamos ordenar por todos los campos,
    pero no de manera individual. En el próximo ejemplo se muestra como hacer.

    #+BEGIN_SRC sql
      SELECT stock_num, manu_code, unit_price
        FROM products
       WHERE manu_code IN ('HRO', 'HSK')
       ORDER BY CASE
                WHEN manu_code='HRO' THEN stock_num  -- no podemos pone ASC ni DESC acá
                WHEN manu_code='HSK' THEN unit_price -- no podemos pone ASC ni DESC acá
                END ASC; -- sólo acá podemos poner la manera de ordenar
    #+END_SRC
*** Ejemplo 5 - En la cláusula ORDER BY con varios criterios de ordenamiento
    En este la sintáxis cambia un poco a diferencia de los primeros dos ejemplos.
    Tenemos que usar ~CASE WHEN nombre_columna=valor_columna THEN otra_columna END~
    es decir por cada posible valor repetimos la *sentencia case*

    *Observación:*
    Podemos notar que cada ~case~ puede tener su forma de ordenar (~ASC~ y ~DESC~) de forma independiente.
    Si quisieramos aplicar la sintáxis de los ejemplos anteriores, NO sería posible para cada uno por separado.

    #+BEGIN_SRC sql
      SELECT cod_producto, cod_fabricante, precio FROM productos
       WHERE cod_fabricante IN ('HRO', 'HSK')
       ORDER BY CASE WHEN cod_fabricante='HRO' THEN cod_producto END ASC,
                CASE WHEN cod_fabricante='HSK' THEN precio END DESC;
    #+END_SRC
*** Ejemplo 6 - En la instrucción UPDATE con un condicional tipo IF
    Similar al ejemplo (2) que usabamos en la *cláusula* ~SELECT~ de la instrucción ~SELECT~

    #+BEGIN_SRC sql
      UPDATE productos
         SET precio=(
           CASE
           WHEN precio < 100 THEN precio*1.10 -- aumentamos un 10%
           WHEN precio < 200 THEN precio*1.20 -- aumentamos un 20%
           ELSE precio*1.50 -- aumentamos el valor un 50%
           END
         ) WHERE fabricante='IBM';
    #+END_SRC
*** Ejemplo 7 - En la instrucción SET con consultas
    - Utilizamos el ~WHEN EXISTS~ seguido entre paréntesis de una *query*
    - El ~SET~ como instrucción se usa para asignar un valor a una *variable* que declaremos
      (también podíamos usar la instrucción ~SELECT~)

    #+BEGIN_SRC sql
      -- 1. Declaramos las variables
      DECLARE @cod_empleado INT;
      DECLARE @TipoContacto VARCHAR(30); -- en esta guardaremos el resultado

      -- 2. Le asignamos un valor (del mismo tipo) según lo que devuelva la consulta
      SET @TipoContacto=
        CASE
          -- si se cumple, su valor será Empresario
          WHEN EXISTS(SELECT * FROM Ventas.empleados v WHERE v.cod_empleado=@cod_empleado)
          THEN 'Empresario'

          -- si se cumple, su valor será Vendedor
          WHEN EXISTS(SELECT * FROM Compras.empleados c WHERE c.cod_empleado=@cod_empleado)
          THEN 'Vendedor'
        END;
    #+END_SRC
* Sentencias Cíclicas
** Conceptos
   - Podemos utilizar la sentencia ~WHILE~ para generar el ciclo
   - Se pueden usar las cláusulas ~BREAK~ y ~CONTINUE~ dentro del bloque de ~WHILE~
** Cláusula BREAK
   Con la cláusula ~BREAK~ abandona el bloque del ~WHILE~ y sigue con la próxima instrucción
   que le siga a ~END~ (el que finaliza el bloque explícito)
** Cláusula CONTINUE
   Con la cláusula ~CONTINUE~ NO ejecuta la próxima instrucción y sigue con la próxima iteración del ~WHILE~
** Ejemplo 1 - Modificar varios registros
  #+BEGIN_SRC sql
    -- Mientras el promedio de todos los precios sea menor  a 900 que siga iterando
    WHILE (SELECT AVG(precio) FROM productos) < 1000
      BEGIN
        -- aumentamos todos los precios en un 10%
        UPDATE productos SET precio = precio*1.10

        -- si algún registro supera los 1500, cortamos la iteración con BREAK
        IF (SELECT MAX(precio) FROM productos) > 4500
          BREAK
        ELSE
          PRINT 'Estamos actualizando los precios.. Muahaha..!'
      END
      PRINT 'Se actualizaron todos los precios.. NO te asustes (?)' -- termina el ciclo
    GO
  #+END_SRC
* IDENTITY - Obtener el valor del último campo con Identity
** Conceptos
  - Con ~IDENTITY~ se puede incrementar el valor de un campo de 1 en 1 (ó el intervalo que uno quiera)
  - NO se deben ingresar valores en la columna definida con ~IDENTITY~
  - Cada vez que se inserta un registro en la tabla, el valor de ese campo se incrementará (según como se haya definido)
  - El valor de último ~IDENTITY~ se guarda en una tabla de la sesión actual
** Ejemplo
#+BEGIN_SRC sql
  -- Creamos una tabla de ejemplo
  CREATE TABLE productos (cod_producto uniqueidentifier NOT NULL, descripcion VARCHAR(250) NOT NULL)

  -- Simulamos que nos olvidamos de agregar la columna,
  -- y queremos agregarla sin borrar y crear la tabla de nuevo
  ALTER TABLE productos
  ADD idProducto INT IDENTITY(1,1)
  GO

  -- Insertamos múltiples registros, con datos ficticios
  INSERT INTO productos VALUES (NEWID(), 'auto rojo'), (NEWID(), 'casa vieja'), (NEWID(), 'moto nueva'), (NEWID(), 'coche moderno')

  -- Guardamos el valor en nuestra variable @ultimo_producto_id
  -- el alcance es más amplio con @@ (porque es una variable global)
  SET @ultimo_producto_id = @@IDENTITY

   -- Otra manera.. pero para obtener el identity local
  SELECT @ultimo_producto_id = SCOPE_IDENTITY()

  -- modificamos la tabla, y borramos la nueva la columna que tenia IDENTITY
  ALTER TABLE #clientesPremium
  DROP Column idCliente  -- suponiendo si queriamos borrar la columna.. :(
  GO
#+END_SRC
* Manejo de excepciones y Transacciones
** Ejemplo 1
  #+BEGIN_SRC sql
    CREATE tabla(
      numero INT PRIMARY KEY
    );

    BEGIN try
      BEGIN tan
      INSERT INTO tabla VALUES (1)
      INSERT INTO tabla VALUES (1)
      COMMIT tran
    END try

    BEGIN catch
      print 'error no se pueden repetir las PK'
      ROLLBACK tran
    END catch
  #+END_SRC
** Ejemplo 2
   #+BEGIN_SRC sql
     ALTER TABLE #clientes
       ADD PRIMARY KEY (customer_num);

     BEGIN TRY -- "intentamos" ejecutar la siguiente transaccion, que tiene varios INSERT
       BEGIN TRANSACTION
       -- ahora.. si intentamos insertar varios registros, con mismo valor en la columna que es PK, fallara..!
       INSERT INTO #clientes (customer_num, fname, address1) VALUES (900, 'pedrito', 'Viamonte 955')
       INSERT INTO #clientes (customer_num, fname, address1) VALUES (900, 'pedrito', 'Viamonte 955')
       INSERT INTO #clientes (customer_num, fname, address1) VALUES (900, 'pedrito', 'Viamonte 955')
       COMMIT TRANSACTION
     END TRY
     BEGIN CATCH -- capturamos la excepción
       PRINT 'ERROR..! REGISTROS CON PK REPETIDA!! >:('
     END CATCH
   #+END_SRC
* Store procedures
** Conceptos
  - las variables con @ son locales, y @@ para las globales
  - otorga un nivel de seguridad extra
    (porque se permite ejecutar el procedure, y no los SELECT)
  
  *Observación:*
  - Las expresiones entre corchetes [ ] quieren decir que son opcionales

  #+name: procedure-sintaxis 
  #+BEGIN_SRC sql
    CREATE PROCEDURE [esquema].[nombre_proc] (parametros de entrada ó de salida) AS
      -- sentencias SPL y/o SQL
    GO
  #+END_SRC
** Parámetros de Entrada/Salida
   Por defecto los parámetros son ~IN~ es decir que son *variables de entrada* que se usarán
   como variables locales dentro del SP.
   Si al parámetro le agregamos ~OUT~ indicamos que algún resultado dentro del SP se guardará en él,
   y tanto en la creación del SP como en su ejecución debe aparecer ~OUT~ 

   |-----------+---------------------------------------------------------------------|
   | Parámetro | Descripción                                                         |
   |-----------+---------------------------------------------------------------------|
   | IN        | Indica que será un parámetro de entrada, será variable local del SP |
   |-----------+---------------------------------------------------------------------|
   | OUT       | Indica que se guardará algún resultado del SP                       |
   |-----------+---------------------------------------------------------------------|

   #+BEGIN_SRC sql
     -- en este caso @var1 y @var2 son parámetros de entrada, por defecto tienen IN
     CREATE PROCEDURE suma1 @var1 INT, @var2 INT AS
     RETURN @var1+@var2
     GO 

     -- en este caso @var1 es un parámetro de entrada, y @var2 uno de salida
     CREATE PROCEDURE suma2 @var1 INT, @var2 INT OUT AS
     SET @var2 = @var1 + 10
     GO 
   #+END_SRC
** Ejemplos
*** Ejemplo 1 - Con dos parámetros y retornando valor
    #+BEGIN_SRC sql
      CREATE PROCEDURE suma @var1 INT, @var2 INT AS
      DECLARE @var3 INT         -- declaramos una tercera variables
      SET @var3 = @var1 + @var2 -- le asignamos un valor
      RETURN @var3              -- la retornamos
      GO

      /*
       ,* 1. Declaramos la variable y su tipo de dato
       ,* 2. Ejecutamos el procedimiento y se lo asignamos a la variable
       ,* 3. Lo imprimimos con SELECT, aunque podríamos haber usado PRINT
       ,*/
      DECLARE @resultado INT
      EXECUTE @resultado = suma 3 2 -- alternativa: usar "exec"
      SELECT @resultado
      GO
    #+END_SRC
*** Ejemplo 2 - Con un parámetro de entrada y otro de salida
    #+BEGIN_SRC sql
      /*
       ,* A la variable que le agregamos "OUT" es la que tendrá
       ,* el resultado de la operación que hagamos.
       ,*
       ,* IMPORTANTE!! Ese OUT debe aparecer en la creación del SP
       ,* como en su ejecución (al usar EXECUTE ó EXEC)
       ,*/
      CREATE PROCEDURE suma @var1 INT, @var2 INT OUT
      AS
      SET @var2 = @var1 + 10;
      GO

      -- 1. Declaramos la variable
      DECLARE @resultado INT
      -- 2. Ejecutamos el SP, le pasamos el parámetro de entrada y el de salida
      EXECUTE suma 2, @resultado OUT
      SELECT @resultado
      GO
    #+END_SRC
** Modificarlos
  - Con ~alter procedure~ se modifican
** Ejecutarlos
   Con la instrucción ~EXECUTE~ ó también ~EXEC~ seguido del nombre del procedimiento

   #+BEGIN_SRC sql
     -- esto va a devolver siempre 10, porque por más que recibe dos parámetros
     -- sólo le estamos asignando el valor 10 al tercer parámetro
     CREATE PROCEDURE suma @var1 INT, @var2 INT, @var3 INT AS
     BEGIN
     DECLARE @resultado int
     SET @resultado = 10
     END
     GO

     DECLARE @resultado int;
     EXECUTE suma 15,13, @resultado
     SELECT @resultado
   #+END_SRC
** Sentencias de manejo de bloques
*** Conceptos
    + Un *bloque explícito* se inician con ~BEGIN~ y finalizan con ~END~
    + Un *bloque implícito* se forma con lo que esté despues del ~AS~ y antes del ~BEGIN .. END~
*** Ejemplos
    #+BEGIN_SRC sql
      CREATE PROCEDURE nombre AS
      -- bloque implícito
      DECLARE @var1 INT  
      SET @var1 = 10

      BEGIN -- inicio de "bloque explícito"
            -- sentencias
      END   -- fin de "bloque explícito"
    #+END_SRC
** Ejecutar comandos del SO
   #+BEGIN_SRC sql
   #+END_SRC
* Store Procedures y Transacciones
** Ejemplo
   #+BEGIN_SRC sql
     CREATE PROCEDURE borrar_clientes @ClienteNumDesde INT, @ClienteNumHasta INT AS
     BEGIN TRANSACTION
     UPDATE #clientes SET fname = fname+' MOROSO'
       WHERE customer_num BETWEEN @ClienteNumDesde AND @ClienteNumHasta

     IF (MONTH(getdate()) < 12) -- si la fecha actual, tiene como número de mes menor a 12
       COMMIT TRANSACTION       -- entonces aplicamos los cambios del UPDATE, con COMMIT
     ELSE
       ROLLBACK TRANSACTION     -- si el número de mes actual es > a 12, cancelamos los cambios con ROLLBACK
     GO

     SELECT * FROM #clientes			      		-- 1. seleccionamos antes del sp
     EXECUTE dbo.borrar_clientes 101, 105	-- 2. ejecutamos el store procedure
     SELECT * FROM #clientes					      -- 3. evaluamos si hubo cambios luego de ejecutar el sp
     GO
   #+END_SRC
* Funciones
** Conceptos
   La sintáxis es similar a los *store procedures*, con la diferencia que se pueden ejecutar dentro de *queries*
   mientras que los *store procedures* NO se pueden ejecutar en una *query*

   IMPORTANTE:
   los *store procedures* NO se pueden ejecutar en una *query*
** Funciones de Usuario
   Se pueden ejecutar dentro de una consulta (sentencia sql)
   (Mientras que los *store procedure* NO pueden ser ejecutados dentro de una *query*)
** Funciones propias por el Motor (built-in function)
   - Funciones agregadas (~SUM~, ~COUNT~, ~AVG~, ..)
   - Otras funciones como ~coalese~
** Ejemplos
   #+BEGIN_SRC sql
     IF OBJECT_ID('eldoble') IS NOT NULL
       DROP FUNCTION dbo.eldoble
     GO

     CREATE FUNCTION eldoble (@var1 DECIMAL(6,2)) RETURNS DECIMAL(6,2) AS
     BEGIN
       DECLARE @var2 DECIMAL(6,2);
       SET @var2 = @var1 * 2;
       RETURN @var2;
     END
     GO

     SELECT dbo.eldoble(2)
     GO
   #+END_SRC
* Cursores
** Conceptos
   - Un *cursor* se define con su declaración usando ~DECLARE~
   - Permiten tomar datos de un ~SELECT~ y leer registro por registro como una iteración
   - NO hay límite de cursores abiertos ni declarados (pero recordar cerrarlos)

   La estructura que se debe seguir es
   1. Declarar el nombre de cursor
   2. Asociar la consulta ~SELECT~ de sql que va a ejecutar, y recorrerá fila por fila
   3. Abrir el cursor (se cargará en memoria)
   4. Usar ~FETCH~ y ~INTO~ para avanzar y guarda los datos de cada registro/fila
      - Con ~FETCH~ para obtener la siguiente fila
      - Con ~INTO~ para insertar los valores de la columna en las variables declaradas
   5. Iterar con ~WHILE (@@FETCH_STATUS = 0)~ sobre las filas de la consulta asociada
      - Con ~WHILE~ creamos la sentencia ciclica
      - Con ~@@FETCH_STATUS~ actúa como *centinela* cortando el cilo de iteración,
        al tener ~@@~ una variable global, e indica si quedan registros por leer
   6. Definimos un *bloque explícito*
      - Delímitado por ~BEGIN~ y ~END~
      - Dentro colocamos las sentencias SQL que queramos
   7. Volvemos a colocar el ~FETCH~ y ~INTO~ tal cual como estaba luego de abrir el cursor
      (con esto pedimos la siguiente fila, y guardamos nuevamente los valores de las columnas
       en las variables declaradas al principio)
   8. Cerramos el cursor con ~CLOSE~
   9. Desalojamos el cursor de la memoria con ~DEALLOCATE~

   #+name: cursor-sintaxis
   #+BEGIN_SRC sql
     DECLARE nombre_cursor CURSOR
     FOR sentencia_sql
     OPEN nombre_cursor
     FETCH nombre_cursor INTO lista_variables
     WHILE (@@FETCH_STATUS=0)
     BEGIN -- bloque de sentencia "explícita" - inicio
     -- sentencias sql
     FETCH nombre_cursor INTO lista_variables
     END   -- bloque de sentencia "explícita" - fin
     CLOSE nombre_cursor
     DEALLOCATE nombre_cursor
   #+END_SRC
** Ejemplos
*** Ejemplo 1 - Imprimir el nombre y apellido de clientes
    #+BEGIN_SRC sql
      /*
      ,* - Cursor: ClienteInfo
      ,* - Variables donde guardar los datos: @Cliente
      ,* - Query asociada al Cusor: SELECT fname+','lname FROM dbo.customer
      ,*/
      -- 1. Declaramos las variables donde guardaremos datos de las columnas
      DECLARE @ClienteCod SMALLINT, @ClienteNomApe VARCHAR(40)
      -- 2. Declaramos el cursor, y le asociamos una query SELECT
      DECLARE ClienteInfo CURSOR FOR
      SELECT customer_num, fname+','+lname FROM dbo.customer
      -- 3. Abrimos el cursor
      OPEN ClienteInfo
      -- 4. Obtenemos el primer registro de la consulta asociada al cursor
      -- y guardamos el resultado de las columnas en la variables declaradas
      -- (en el mismo orden que la consulta SELECT)
      FETCH NEXT FROM ClienteInfo INTO @ClienteCod, @ClienteNomApe
      -- 5. Iteramos mientras hayan registros
      -- (la condicion de corte es cuando sea distinto de cero)
      WHILE @@FETCH_STATUS=0
        BEGIN
          --PRINT CAST(@ClienteCod as VARCHAR(10))+ ':'+@ClienteNomApe
          PRINT CONVERT(VARCHAR(10), @ClienteCod)+ ':'+@ClienteNomApe
          -- en cada iteracion, pedimos el siguiente registro
          FETCH NEXT FROM ClienteInfo INTO @ClienteCod, @ClienteNomApe
        END
      -- 6. Cerramos y desalojamos el cursor
      -- (se borra la referencia al cursor, se liberan los recursos asignados al proceso, se desloja el proceso de la memoria)
      CLOSE ClienteInfo
      DEALLOCATE ClienteInfo
      GO
      -- Obs: Con GO hacemos que las instrucciones anteriores sean atomicas, y me permite volver a declarar variables con mismo nombre
    #+END_SRC
*** Ejemplo 2 - Seleccionar registros de una tabla e insertar en otra tabla
   #+BEGIN_SRC sql
     DECLARE items_almacen CURSOR FOR 
     SELECT id_item FROM tabla_items WHERE id_almacen = @cod_almacen
     -- declaramos una variable para el cursor (queda en memoria)
     DECLARE @item_del_cursor INTEGER
     -- a una area de memoria, le agrega filas del select
     OPEN items_almacen
     -- busca la primera fila del primer select
     FETCH items_almacen INTO @item_del_cursor
     -- mientras haya mas filas/registros ejecuta lo de adentro del while
     WHILE (@@FETCH_STATUS =0)
     BEGIN -- bloque de sentencia explícito - inicio
       INSERT INTO tabla_items_aux VALUES (@item_del_cursor)
       FETCH NEXT FROM items_almacen INTO @item_del_cursor 
     END -- bloque de sentencia explícito - fin
     CLOSE items_almacen
     DEALLOCATE items_almacen
   #+END_SRC
*** Ejemplo 3 - Cursor con Store Procedure que recibe dos parámetros
    #+BEGIN_SRC sql
      CREATE PROCEDURE mejoresClientes @Cliente_CodDesde SMALLINT, @Cliente_CodHasta SMALLINT AS
      DECLARE @ClienteNum SMALLINT
      DECLARE @ClienteNom VARCHAR(20), @ClienteDir VARCHAR(20)
      DECLARE ClienteInfo CURSOR FOR SELECT customer_num, fname, address1 FROM #clientes

      OPEN ClienteInfo
      FETCH NEXT FROM ClienteInfo INTO @ClienteNum, @ClienteNom, @ClienteDir
      WHILE @@FETCH_STATUS=0
      BEGIN
        PRINT @ClienteNom+', '+@ClienteDir
        INSERT INTO #clientesPremium VALUES (@ClienteNum, @ClienteNom, @ClienteDir)
        FETCH NEXT FROM ClienteInfo INTO @ClienteNum, @ClienteNom, @ClienteDir
      END
      CLOSE ClienteInfo
      DEALLOCATE ClienteInfo
      GO

      EXECUTE dbo.mejoresClientes 101, 110
      SELECT * FROM #clientesPremium
    #+END_SRC
*** Ejemplo 4 - Cursor con una tabla temporal de ejemplo
    #+BEGIN_SRC sql
      CREATE TABLE #ITEMS (ITEM_ID uniqueidentifier NOT NULL, ITEM_DESCRIPTION VARCHAR(250) NOT NULL)
      INSERT INTO #ITEMS VALUES (NEWID(), 'autito'), (NEWID(), 'casit'), (NEWID(), 'motito'), (NEWID(), 'coche')

      -- (Declaramos una variable que contendra el ID de cada fila)
      -- (Obs #1: Tendra que haber tantas variables declaradas, como columnas de la consulta
      -- asociada al cursor)
      DECLARE @ITEM_ID uniqueidentifier
      -- 1. Declaramos el cursor, y le asociamos la consulta SELECT con la que iterara
      -- (en este ejemplo, la consulta tendrá solo 1 columna)
      DECLARE ITEM_CURSOR CURSOR FOR         -- declaracion del cursor
      SELECT ITEM_ID FROM #ITEMS             -- consulta SELECT asociada al cursor
      -- 2. Cargamos los resultados a memoria
      -- (ademas ejecuta la consulta SELECT asociada al cursor)
      OPEN ITEM_CURSOR
      -- 3. Obtenemos (fetch) el primer resultado
      -- (Obs: Copiamos el resultado solo a 1 variable, pero si el SELECT del cursor
      -- tuviera mas columnas, tendriamos que agregarlas en el INTO en el mismo orden)
      FETCH NEXT FROM ITEM_CURSOR           -- FETCH: obtenemos el sig. resultado
      INTO @ITEM_ID                         -- INTO: lo copiamos a una variable (podrian ser a mas)
      -- 4. Si hay resultados para operar, sigue iterando
      -- (Evalua si la lectura del sig. registro es valida, si es asi el valor es cero,
      -- recordemos que @@ es para variables globales)
      WHILE @@FETCH_STATUS = 0
        -- agregamos un bloque con BEGIN...END, con la consulta que queramos
        BEGIN
        SELECT ITEM_DESCRIPTION FROM #ITEMS
        WHERE ITEM_ID = @ITEM_ID -- In regards to our latest fetched ID
         -- 5. Cuando terminó de ejecutar la consulta, continúa con el siguiente
        FETCH NEXT FROM ITEM_CURSOR INTO @ITEM_ID
        END
      -- 6. Finaliza cuando @@FETCH_STATUS indica que no hay más resultados
      -- (se liberan los registros tomados por el cursor, no se pueden seguir usando
      -- a menos que se reabra el cursor)
      CLOSE ITEM_CURSOR
      -- 7. Se libera los datos de memoria y se limpia el proceso
      -- (se elimina la referencia al cursor)
      DEALLOCATE ITEM_CURSOR
    #+END_SRC
*** Ejemplo 5 - Ejercicio complejo de la Guia de ejercicios
    #+BEGIN_SRC sql
      -- creamos la tabla a modo de utilizar el SP
      CREATE TABLE customerStatistics(
        customer_num INT PRIMARY KEY,
        ordersqty INT,
        maxdate Date,
        uniqueProducts INT
      );
      -- Chequemos que se haya creado
      SELECT * FROM dbo.customerStatistics;
      GO -- agregamos este GO ara que el sig. SP sea la unica instruccion del lote (tambien conocido por Batch)

      CREATE PROCEDURE actualizaEstadisticas  @customer_numDESDE INT, @customer_numHASTA INT AS
      BEGIN
        -- 1. Declara el cursor, le asocia la consulta SELECT (que tiene solo 1 columna)
        -- (utiliza los parametros como filtro en la clausula WHERE)
        DECLARE CustomerCursor CURSOR FOR
          SELECT customer_num FROM customer WHERE customer_num BETWEEN @customer_numDESDE AND @customer_numHASTA

        DECLARE  @customer_num INT, @ordersqty INT, @maxdate DATETIME,  @uniqueManufact INT -- declara algunas variables locales
        -- 2. Abre el cursor
        OPEN CustomerCursor
        -- 3. Obtiene el primer registro del SELECT asociado al cursor, y guarda el dato de la unica columna del SELECT en la variable declarada (customer_num)
        FETCH NEXT FROM CustomerCursor INTO @customer_num
        -- 4. Mientras hayan registros itera (la condicion de corte es cuando la variable global fetch_status sea distinto de cero)
        WHILE (@@FETCH_STATUS = 0)
          -- inicia un "Bloque explicito" con BEGIN...END, para ejecutar varias queries
          BEGIN
            -- # Consulta nro 1:
            -- obtiene de un cliente especifico (el que se paso por parametro en el SP):
            -- la fecha del ultimo pedido y lo guarda en la variable local @ordersqty
            -- y la cant. de pedidos que hizo y lo guarda en la variable local @maxDate
            SELECT @ordersqty=count(*) , @maxDate=max(order_date) FROM orders WHERE customer_num = @customer_num;

            -- # Consulta nro 2:
            -- selecciona  la cantidad de fabricantes, asociando los productos que ordeno el cliente especifico en cada pedido
            -- y los guarda en la variable local @uniqueManufact
            -- Obs: Ojo...! Porque esta haciendo una query de producto cartesiano.. (NO son performantes)
            SELECT @uniqueManufact=count(distinct stock_num)  FROM items i, orders o
            WHERE o.customer_num = @customer_num  AND o.order_num = i.order_num;

                  -- # Consulta nro 3:
            -- si el registro del cliente especifico, no aparece en la tabla,
            -- entonces inserta un registro con los datos almacenados en las variables locales  @ordersQty, @maxDate, @uniqueManufact
            -- (Obs: Ojo con el orden de los values, la tabla debe haber sido creada con las columnas en ese orden
            -- a menos que.. pongamos los nombres de las columnas previo al nombre de la tabla donde se insertan los registros)
            IF NOT EXISTS( SELECT 1 FROM CustomerStatistics WHERE customer_num = @customer_num)
              insert into customerStatistics values (@customer_num,@ordersQty, @maxDate,@uniqueManufact);
            -- # Consulta nro 4:
            -- si el registro ya existe, osea ya fue insertado,
            -- entonces actualizamos ese registro con los valores almacenados en las variables locales @ordersQty, @maxDate, @uniqueManufact
            ELSE
              UPDATE customerStatistics SET  ordersQty=@ordersQty,maxDate=@maxDate, uniqueProducts=@uniqueManufact
              WHERE customer_num = @customer_num;

              -- 5. Avanza al siguiente registro (este FETCH debe ser identico al anterior, al que se usa para obtener el primer registro)
            FETCH NEXT FROM CustomerCursor INTO @customer_num
          END; -- aca termina el "bloque explicito"
        -- 6. Cierra el cursor, elimina la referencia al cursor, y lo desaloja el proceso de la memoria (liberando los recursos que utilizaba)
        CLOSE CustomerCursor;
        DEALLOCATE CustomerCursor;
      END

      -- 1. revisamos que clientes hay, para sacar el customer_num y pasar esos valores como parametro al SP
      SELECT * FROM dbo.customer;
      -- 2. ejecutamos el (SP, store procedure) y.. deberia insertar registros y/o actualizar la tabla customerStatistics
      EXECUTE dbo.actualizaEstadisticas 101,110;
      -- 3. verificamos que hayan habido cambios luego de ejecutar el SP
      SELECT * FROM dbo.customerStatistics;
    #+END_SRC
* Parte práctica
 #+BEGIN_SRC sql
   CREATE PROCEDURE actualizaEstadisticas  
		     @customer_numDES INT , @customer_numHAS INT 
   AS 
   BEGIN 
      DECLARE CustomerCursor CURSOR FOR 
 SELECT customer_num from customer WHERE customer_num  
		  BETWEEN @customer_numDES AND @customer_numHAS 
 
     DECLARE  @customer_num INT, @ordersqty INT, @maxdate DATETIME, 
		      @uniqueManufact INT; 
  
     OPEN CustomerCursor; 
     FETCH NEXT FROM CustomerCursor INTO @customer_num 
     WHILE @@FETCH_STATUS = 0 
     BEGIN 
    
	SELECT @ordersqty=count(*) , @maxDate=max(order_date)  
	  FROM orders 
	 WHERE customer_num = @customer_num; 
 
	 SELECT @uniqueManufact=count(distinct stock_num) 
	   FROM items i, orders o 
	  WHERE o.customer_num = @customer_num 
	    AND o.order_num = i.order_num;
 
	 IF NOT EXISTS( SELECT 1 FROM CustomerStatistics  
			 WHERE customer_num = @customer_num) 
 
     insert into customerStatistics  
		    values (@customer_num,@ordersQty, @maxDate,@uniqueManufact);
	 ELSE 
	 update customerStatistics   
		  SET  ordersQty=@ordersQty,maxDate=@maxDate,   
		 uniqueManufact= @uniqueManufact 
		   WHERE customer_num = @customer_num; 

	 FETCH NEXT FROM CustomerCursor INTO @customer_num 
     END; 
     CLOSE CustomerCursor; 
     DEALLOCATE CustomerCursor; 
    END
 #+END_SRC
