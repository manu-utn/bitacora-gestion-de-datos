#+TITLE: Clase 04 - Secuencias y Tablas Temporales

#+BEGIN_COMMENT
  1. Pagina 8 - Secuencias (???) como sin huecos (?)
  2. <<DUDA 1>> (pagina 29)
#+END_COMMENT

* DML (Data Manipulation Language)
** Conceptos previos
*** Constraints
**** Integridad de Entidad
     Asegura que cada registro/fila se identifica unívocamente
     por una ~primary key~ (que NO sea nula)
**** Integridad Referencial
     Asegura la *coherencia* entre dos tablas
     cuando se asocian a través de la ~foreing key~ 
     que hace referencia a la ~primary key~ de la otra tabla
** Conceptos
   Se utilizan las siguientes operaciones para manipular los datos 
   - Insert
   - Update
   - Delete
   - Merge
** Insert
*** Insertar una sola fila
**** Conceptos
     + Es opcional agregar los nombres de las columnas
     + Si NO agregamos la *lista de columnas* de los datos a insertar 
       * Podemos tener problemas si se agregaron/borraron columnas
         (porque podemos insertar datos en una columna incorrecta)
       * Nos obliga a poner los valores en el mismo orden que como
         fueron definidas las columnas de la tabla
         (*acoplando* la consulta al modelo/definición de la tabla
       * Puede agregarnos como dato el valor ~NULL~
     + Si agregamos la *lista de columnas* de los datos a insertar
       estamos *desacoplando* la instrucción de la *definición de la tabla*

     *Observación:*
     - Se recomienda agregarle los nombres de las columnas
     - Podemos evitar pasar los nombres de las columnas, a aquellos campos
       que sabemos que tienen un ~DEFAULT~ definido, ó que no interesa
       si su valor es ~NULL~

     #+BEGIN_SRC sql
       -- las expresiones entre corchetes [] son opcionales
       INSERT INTO Nombre_tabla [(lista decolumnas)]
       VALUES (lista de valores);
     #+END_SRC
**** Ejemplos
     #+BEGIN_SRC sql
       -- si no le pasamos las columnas, puede "quizas" funcionar,
       -- pero.. NO se recomienda porque
       -- 1. pueden "NO matchear con los tipos" definidos de las columnas
       -- definidas en la tabla
       -- 2. completará con NULL, los campos que nos olvidemos agregar
       -- 3. podemos estar ingresado datos en una columna erronea
       -- apesar que los tipos coincidan
       INSERT INTO product_types
         VALUES (375, 'short baño');

       -- le pasamos las columnas
       INSERT INTO product_types (stock_num, description)
       VALUES (375, 'short baño');
     #+END_SRC
*** Insertar mútiples filas
**** Conceptos
     Podemos combinar las operaciones ~select~ con ~insert~ 
     1. Indicamos la tabla destino con ~insert~
     2. seguido de ~select~ le pasamos el conjunto de datos

     *Observación:*
     - NO se recomienda utilizar el asterísco en el ~select~
       podría traernos columnas que no queremos, y que 
       no coinciden con la tabla destino
**** Ejemplos
     #+BEGIN_SRC sql
       -- insertamos en base a una query
       -- 1. NO se recomienda usar el asterisco * en el SELECT
       -- Obs: CUIDADO CON LOS PARENTESIS.. NO ES UNA "SUBQUERY", eso produce un error sintáctico
       INSERT INTO closed_orders
                   SELECT * FROM orders
                     WHERE paid_date IS NOT null;

       INSERT INTO closed_orders
                   (SELECT (order_num, order_date) FROM orders
                     WHERE paid_date IS NOT null);
     #+END_SRC
*** Constraint Default
    si NO le agregamos la *lista de columnas* al ~insert~ 
    los datos de las columnas faltantes tendrán
    + los valores ~NULL~ (por defecto)
    + ó el que hayamos indicado en el ~CONSTRAINT DEFAULT~ 
      (al momento de definir la tabla)
** Update
*** Conceptos
    + La clausula ~WHERE~ es opcional, pero..
       si no se agrega se actualizarán *todas las filas* de la tabla

    #+BEGIN_SRC sql
      UPDATE nombre_tabla
         SET columna=valor[, columna=Valor...],
             [WHERE condiciones];
    #+END_SRC
*** Ejemplos
    #+BEGIN_SRC sql
      UPDATE customer
         SET company = 'UTN', phone ='555'
       WHERE customer_num = 112; -- OK

      -- aumentamos el precio en un 20%
      UPDATE products
         SET precio = precio * 1.20
       WHERE code = 'ANZ'; -- OK

      -- DANGER...!
      -- este update sin where es PELIGROSO
      -- modifica todas las filas
      UPDATE empleados
             SET apellido='pepe';
    #+END_SRC
** [TODO] Delete
*** Conceptos
     + La clausula ~WHERE~ es opcional, pero..
        si no se agrega se actualizarán *todas las filas* de la tabla
  
     *Obsevación:*
     - Cuidado con la *integridad referencial* por las (PK y FK)

    <<DUDA 1>>: Entonces q sucede? se puede o no?
    Si tratamos de borrar filas donde las PK estan referencias por otra
    tabla (osea son FK en otra) seguramente no nos deje borrar
    por lo de *integridad referencial*

    #+BEGIN_SRC sql
      DELETE FROM nombre_tabla
                  [WHERE condiciones];
    #+END_SRC
*** Ejemplos
    #+BEGIN_SRC sql
      DELETE FROM customer
       WHERE customer_num = 266; -- ok
    #+END_SRC
** Merge
*** Conceptos
    - Para realizar *procesamientos batch* (migraciones, apareos, ..)
      - Su traducción al español es *procesamiento por lotes*
      - Operaciones que no requieren la interacción/supervisión del usuario

    #+BEGIN_SRC sql
      MERGE <tabla_destino> -- tabla que será modificada
        USING <tabla_fuente> -- tabla base
        ON <condicion_inicial> -- podemos asociar PK y FK

        -- Si la condicion inicial se cumple, coinciden PK y FK
        -- y.. algunas condiciones extra (si queremos)
        [ WHEN MATCHED [AND <condicion>]
        -- podemos actualizar las columnas de la "Tabla destino"
        -- en base a lo que tiene la "Tabla fuente"
        THEN <operaciones>]

        -- Si la condicion inicial NO coincide, NO coinciden las PK y FK
        -- (porque tabla_fuente tiene registros, que no tiene tabla_destino)
        [WHEN NOT MATCHED [BY TARGET] [AND <condicion>]
        -- Podriamos insertar los datos, en la tabla destino
        THEN <operaciones>]

        -- Si la condicion inicial NO coincide con la "Tabla fuente"
        -- (porque la tabla_destino tiene registros, que no tiene tabla_fuente)
        [WHEN NOT MATCHED BY SOURCE [AND <ccondicion>]
        -- Podriamos borrar los registros de la tabla_destino
        THEN <operaciones>]
        [ <output_clause> ]; -- y esta?
    #+END_SRC
*** Ejemplos
    #+BEGIN_SRC sql
      MERGE tabla_destino d
        USING tabla_fuente f
        ON d.codigo = f.codigo

        -- si la condición de codigos se cumple
        -- y además las direcciones son diferentes
        WHEN MATCHED AND d.direccion <> f.direccion THEN
        -- actualizamos la columna dirección de la tabla_destino
        SET d.direccion = f.direccion

        -- si la condición de codigos no se cumple
        -- respecto de tabla_destino (target)
        WHEN NOT MATCHED BY TARGET THEN
        -- insertamos los registros faltantes, que no tiene
        INSERT (codigo, nombre, direccion)
        VALUES (f.codigo, f.nombre, f.direccion)

        -- si la condición de codigos no se cumple
        -- respecto de tabla_fuente (source)
        WHEN NOT MATCHED BY SOURCE THEN
        -- borramos de tabla_destino los registros
        -- que no tenga la tabla_fuente
        DELETE;
    #+END_SRC
* Secuencias
** Conceptos
  - Es un *objeto Secuence* que todos los motores de db soportan
    (En myql es autoincrement, en sql es identity, ...)
  - Genera valores consecutivos únicos (Ej. 1,2,3,... )
  - La implementación en *SQL Server* es como *propiedad de una columna* 
    llamada ~IDENTITY~
  - Las columnas con este objeto NO se puede modificar con ~INSERT~
** Identity
    - al hace un ~insert~ no se deben agregar las columnas  que tengan
      la propiedad ~identity~ en la definición  de la tabla
    - es un autonumerador constante
    - está relacionado con las *secuencias*

    #+BEGIN_SRC sql
      CREATE TABLE empleados(
        -- cada vez que se inserten registros
        -- codEmpleado incrementará de 1 en 1
        codEmpleado INT IDENTITY (1,1) PRIMARY KEY,
        nombre VARCHAR(60),
        apellido VARCHAR(60)
      );

      -- no estamos agregando la columna codEmpleado
      INSERT INTO empleados (nombre, apellido)
                  VALUES ('Carlos', 'Romero');
    #+END_SRC
** Ejemplo en SQL Server
   #+BEGIN_SRC sql
     -- en el motor SQLServer
     CREATE TABLE ordenes(
       orden IDENTITY (1,1), -- incrementará de 1 en 1
       cliente INT NULL,
       total decimal(15,2)
     );
   #+END_SRC
** Ejemplo en otros motores de DB
  #+BEGIN_SRC sql
    -- en el motor Informix
    CREATE TABLE ordenes(
      N_orden SERIAL,
      N_cliente INTEGER,
    );

    -- en el motor MySql el objeto secuence es AUTO_INCREMENT
    CREATE TABLE ordenes(
      N_orden AUTO_INCREMENT,
      N_cliente INTEGER,
    );

    -- en el motor Oracle
    CREATE SECUENCE ordenes
      INCREMENT BY 1
      START WITH 10
      MAXVALUE 9999
      NOCYCLE
      NOCACHE;
  #+END_SRC
* Tablas
  + Son la *unidad básica de almacenamiento* de datos
  + Son de *existencia permanente*
  + Poseen un identificador único por *esquema* ó *base de datos*
  + Cada columna tiene
    1. nombre
    2. tipo de dato
    3. ancho (varía según el tipo de dato)
* Tablas Temporales
** Conceptos
  + Son de *existencia temporal*
  + En SQLServer se deben crear anteponiendo el # numeral en el nombre
  + Con doble numeral ## se crea una tabla temporal del tipo *global*
  + NO se pueden alterar (osea agregar/eliminar columnas, cambiar tipos, ..)
    (Si se pudiera se usaría ~ALTER TABLE~ pero NO se puede)
  
   #+BEGIN_SRC sql
     -- creación de tabla temporal
     -- de forma Explícita
     CREATE TABLE #productos(
       N_orden INTEGER,
       N_cliente INTEGER,
       C_estado SMALLINT
     );

     INSERT INTO #productos
     SELECT * FROM ordenes WHERE c_estado = 1;

     -- creación de tabla temporal
     -- de forma Implícita
     SELECT *
       INTO #ordenes_Pendientes -- esta tabla no existe
       FROM ordenes
      WHERE c_estado = 1;
   #+END_SRC
** Por que usarlas
   - optimizar accesos a una consulta varias veces en una aplicación
   - almacenar resultados intermedios en una aplicación
*** Almacenamiento intermedio de consultas MUY grandes
    - Para dividir una consulta grande en pequeñas consultas
    - Es poco *perfomante* una consulta de gran tamaño
    - Es muy *costoso* una consulta con muchos ~JOIN~
*** Optimizar accesos
    - Para evitar realizar varias veces consultas que demoran mucho en ejecutarse
    - Permite realizar la consulta una sola vez, y consultar directo
      a la tabla temporal
*** Almacenar resultados intermedios
    - Para evitar actualizar las tablas reales de la DB
    - Utilizar las *tablas temporales de sesión* para volcar información
      y luego reutilizar para crear *tablas físicas*
** Tipos
*** De sesión (locales)
    + visibiles *solo para los creadores*
    + se eliminan cuando
      - el usuario se desconecta
      - ó el usuario decide eliminarla
*** Globales
    - visibles para *cualquier usuario*
    - visibles para cualquier sesón
** Tipos de Creacion
*** Explicita
    + Mediante la instrucción ~CREATE~
    + Se debe definir
      * el nombre
      * sus campos (columnas)
      * tipos de datos
      * restricciones (constraints)

    *Observaciones:*
    + NO se recomienda utilizar el * (asterísco) para insertar mútiples registros porque
      1. porque puede haber problemas de tipos de columnas
      2. porque si llegase a cambiar la tabla, los registros quizás tipan pero se ingresarían mal
    + Al insertar multiples registros con ~INSERT INTO~ y ~SELECT~, _no agregar paréntesis_ en la consulta
      del  ~SELECT~ porque NO es una subquery

    #+BEGIN_SRC sql
      -- Es importante notar el símbolo # numeral
      -- antes del identificador/nombre de la tabla
      CREATE TABLE #ordenes_pendientes(
        codOrden INTEGER,
        codCliente INTEGER,
        fecha DATE,
        alta TIMESTAMP
        );

      -- OBS: OJO CON LOS PARÉNTESIS EN EL SELECT.. NO ES UNA "SUBQUERY" (produciría un error sintáctico)
      INSERT INTO #ordenes_pendientes
                  SELECT * FROM ordenes WHERE estado = 1;
    #+END_SRC
*** Implícita
    - Mediante el *resultado de una consulta* ~SELECT~
    
    #+BEGIN_SRC sql
      -- Esto CREA la tabla, no solo inserta datos
      SELECT *
        INTO #ordenes_pendientes
        FROM ordenes
       WHERE estado = 1;
    #+END_SRC
* [TODO] Tablas anidadas
  Pag. 15 de 18-Pesentacion Objetos
  aún no lo dió el profe
* parcial teoria-practica
  1. 2 preguntas teoricas que pueden ser de
     - modelo relacional
     - funciones de una BD
     - objetos de BD
  2. parte practica (queries complejos en sql)
  3. store procedures
  4. triggers
