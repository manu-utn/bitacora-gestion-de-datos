#+TITLE: Lock -Bloqueo
* [TODO] Bloqueo
** Tipo de bloqueo
*** conceptos
    Esta utilizando sql ya bloquea 
*** Compartido (shared)
    estar usando sql ya uno esta bloqueando
*** Exclusivo
    - tiene q estar solo una persona conectada
    - si hay otra persona conectada NO se puede
      (se lo debe desconectar, matar su conexion)
*** Promovible (promotable-update)
** Granularidad 
   - nivel db
   - nivel d tabla
   - nivel de pagina
   - nivel de fila
   - nivel de clave-indice

   Si se bloquea una tabla, tampoco se va a poder acceder a las vistas
   que la utilizan. Porque recorda que son queries..
** Niveles de aislamiento
*** conceptos
  (A)tomicidad
  (I)solated (aislamiento
  (C)onsistencia
  I... (?)

  significa que si hay dos transacciones a la vez,
  no deberian molestarse entre ellas

  hay 4 tipos de aislamiento, de la mas permisiva a la menos permisiiva
*** tipos 
**** read uncommitted
     - es el default
     - es el mas permisivo de los niveles
     - no chequea los bloqueos por select en las tablas a consultar
     - aparece el concepto de ~dirty read~
     - no asegura ~lecturas repetibles~ 
       (hacer una query select dos veces, y muestre los mismos datos)
     - aparece el ~phantom record~

     - no permite ver datos sucios, ni tampoco lecturas repetibles, ni tampoco lecturas fantasmas
     -
**** read commited
**** repeteable read
     - *bloquea a nivel filas* (todas las que estemos leyendo con un SELECT por ej.)

     Ej. si estamos haciendo un SELECT de una tabla con 5 registros, y solo agarramos
     los primeros 3, entonces en la otra sesión no podremos hacer un SET de esas filas
     porque quedan bloqueadas... Pero SI podemos hacerlo con las 2 ultimas.
     Obs: si hacemos un COMMIT o ROLLBACK podremos modificar las 3 primeras.
**** serializable
     - se bloquea la tabla completa
     - es el mas restricto
     - permite hacer una lectura repetible
     - si la tabla no tiene Indice, va a bloquear la tabla completa
*** tipos de lectura
**** dirty read
     - lecturas sucias
     - cuando desde una transaccion leo datos de otra transaccion que aun no esta terminada
     - lee datos que no estan completos (casi incosistente)
     - datos q aun no fueron comiteados
**** phantom records
     - tiene q ver con la ~lectura repetible~
     - son filas que fueron insertadas por otra transaccion y..
     - difiere con repeatable read, porque
     - es una lectura que aparecen filas grabadas que... (?)
     - ej. cuando hacemos dos transacciones (registros de otras transacciones)
**** repeatable reads
     - lecturas repetidas
     - hacer una query select dos veces, y muestre los mismos datos
     - que una consulta puedas hacer tantas veces como quieras,
       y devuelva los mismos datos
*** ejemplos
    - cada vez que abrimos una pestaña de queries,
      se abre una nueva conexion 
    - Si al crear una tabla usamos doble numeral ##
      se crean a nivel sesion

      en este ejemplo podemos ver como seria con o sin read uncommited,
      
    #+BEGIN_SRC sql
      CREATE TABLE ##nums (num INT);

      -- En una conexion hacemos
      BEGIN TRANSACTION
      INSERT INTO ##nums VALUES (1)
      INSERT INTO ##nums VALUES (2)
      INSERT INTO ##nums VALUES (3)
      ROLLBACK

      -- en otra conexion (pestaña)
      -- veremos que queda ahi esperando..
      -- a menos que agreguemos lo siguiente.. cambiando el tipo de "aislamiento"
      -- con esto podremos ir viendo los datos
      -- SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
      -- BEGIN TRANSACTION
      SELECT * ##nums
    #+END_SRC

    #+BEGIN_SRC sql
      -- ejemplo de las phantom read, si hacemos commit de una,
      -- despues un rollback o algo asi, en la sesion 2
      -- creamos otra transaccion e insertamos datos
      -- veremos filas en el select del la sesion 1 de la primera tansaccion
      -- esos son los phantom read

      -- SESION 1
      SET TRANSACTION ISOLATION LEVEL READ COMMITTED
      BEGIN TRANSACTION
      SELECT * FROM ##nums

      -- SSION 2
      ROLLBACK
    #+END_SRC

    #+BEGIN_SRC sql
      -- el repeatable read, le pone un bloqueo exclusivo a cada fila que lee
      -- NO asegura el phantom record
      -- Asegura que los datos NO pueden modificar los datos

      -- SESION 1
      SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
      BEGIN TRANSACTION
      SELECT * FROM ##nums

      -- SESION 2
      BEGIN TRANSACTION
      UPDATE ##nums SET valor=2 WHERE valor=1
      COMMIT
    #+END_SRC

    #+BEGIN_SRC sql
      -- sesion 1
      SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
      BEGIN TRANSACTION
      SELECT * FROM #nums WHERE valor < 7
      -- al hacer esto, crar indices, me deja lo de la sesion 2
      -- nos permite porque se bloquea el indice.. (???)
      -- create index ix1 ON ##nums (valor)

      -- sesion 2
      BEGIN TRANSACTION
      INSERT INTO ##nums VALUES (3)
    #+END_SRC
    
* [TODO] Deadlock
** conceptos
   - cuando dos transacciones quieren leer los mismos datos
   - el motor, mata la transaccion mas nueva
