#+TITLE: DML - Data Manipulation Language
#+STARTUP: inlineimages
* SQL
  - Las siglas *SQL* hacen referencia a *Structured Query Language*
  - Es un (DBMS) *motor de base de datos* que incorpora un (DDL) *lenguaje de definición de datos*
  
  *Observación:*
  Una de las *reglas de CODD* impone que un (DBMS) *Data Base Managment System* (/motor de db/) debe tener
  - un (DDL) *lenguaje de definición de datos* (/CREATE, ALTER, .../)
  - un (DML) *lenguaje de manipulación de datos* (/SELECT, INSERT, UPDATE, DELETE, .../)

  #+BEGIN_SRC plantuml :exports results :file img/instrucciones-sql.png
    @startuml

    title SQL Instrucciones
    top to bottom direction 

    note as N1
    ,* SQL: Structured Query Language
    ,* DML: Data Manipulation Lenguaje
    ,* DDL Data Definition Language
    ,* TCL: Transactional Control Language
    endnote

    note as SQL
    Instrucciones-SQL
    endnote

    note as DDL
    DDL
    ,* CREATE
    ,* ALTER
    ,* DROP
    ,* TRUNCATE
    endnote

    note as DML
    DML
    ,* SELECT
    ,* INSERT
    ,* UPDATE
    ,* DELETE
    endnote

    note as TCL
    TCL
    ,* COMMIT
    ,* ROLLBACK
    endnote

    DDL -up-> SQL
    DML -up-> SQL
    TCL -up-> SQL

    @enduml
  #+END_SRC

  #+RESULTS:
  [[file:img/instrucciones-sql.png]]

* Tricks && Tips
** DER - Ejemplos Interesantes
*** Relación Recursiva
    #+BEGIN_SRC plantuml :file img/relacion-recursiva.png :exports results
      @startuml
      title DER - Relación recursiva
      hide circle
      skinparam linetype ortho

      note as N1
      ,**Productos**
      |= emp_codigo   | emp_nombre    | emp_salario   | emp_jefe  |
      | **001**           | carlos        | 150000         | NULL      |
      | 002           | fede          | 15000         | **001**      |
      | 003           | ricardo       | 25000         | **001**      |
      | 004           | samuel        | 5000         | **003**      |

      ,* El primer registro tiene emp_jefe en NULL 
      porque no tiene ningún jefe, es el jefe de todos
      ,* El empleado 002 y 003 tienen como jefe al 001
      ,* El empleado 004 tiene sólo un jefe, el 003
      endnote

      ''''''''''''''''''''''''''''''''''
      '' ENTIDADES

      entity "Empleado" as empleado {
         empleado_codigo: int
         --
         empleado_nombre: char(50)
         empleado_salario: decimal(4,2)
         empleado_jefe: int
      }

      ''''''''''''''''''''''''''''''''''
      '' RELACIONES

      empleado ||..|| empleado


      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/relacion-recursiva.png]]

*** Doble Relación
    #+BEGIN_SRC plantuml :file img/relacion-doble.png :exports results
      @startuml
      title DER - Relación doble
      hide circle
      skinparam linetype ortho

      note as N1
      ,**Productos**
      |= prod_id   | prod_detalle  | prod_precio   |
      | 001       | gaseosa         | 50           |
      | 002       | fritas        | 100           |
      | 003       | hamburguesa     | 300           |
      | **004**       | bigmac        | 700           |
      | **005**       | superbigmac        | 900           |

      --

      ,**Combos**
      |= combo_producto    |= combo_componente  | combo_cant    |
      | 004               | 001               | 2             |
      | 004               | 002               | 2             |
      | 004               | 003               | 1             |
      | 005               | 001               | 2             |
      | 005               | 002               | 3             |
      | 005               | 003               | 2             |

      Un combo puede estar compuesto por varios productos

      Ej. Una bigmac es un producto, que está formado por 
      tres productos: 2 fritas+ 2 gaseosas +hamburgesa
      endnote

      ''''''''''''''''''''''''''''''''''
      '' ENTIDADES

      entity "Producto" as producto {
         producto_id: char(8)
         --
         producto_detalle: char(50)
         producto_precio: decimal(4,2)
      }

      entity "Combo" as combo {
         combo_producto: char(8) <<FK>>
         combo_componente: char(8)
         --
         combo_cantidad: int
      }

      ''''''''''''''''''''''''''''''''''
      '' RELACIONES

      producto ||.down.o{ combo : R1
      producto ||.down.o{ combo : R2

      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/relacion-doble.png]]

** SELECT DISTINCT Vs Valor NULL
*** Conceptos
   - El ~SELECT DISTINCT~ cuenta al valor ~NULL~ como único valor
   - Si una columna tiene varios registros ~NULL~  => el ~SELECT DISTINCT~ mostrará sólo un ~NULL~ y los registros restantes

   #+BEGIN_QUOTE
   Si hacemos ~SELECT DISTINCT col~ con 10 registros, de los cuales 4 son ~NULL~
   mostrará sólo 1 registro con ~NULL~ y los registros restantes
   #+END_QUOTE
*** Ejemplo
    #+BEGIN_QUOTE
    Si hacemos ~SELECT country FROM Customers~ y éste nos devuelve lo siguiente
    #+END_QUOTE

    |-----------|
    | country   |
    |-----------|
    | argentina |
    | perú      |
    | bolivia   |
    | ~NULL~    |
    | ~NULL~    |
    | ~NULL~    |
    | ~NULL~    |
    |-----------|

    #+BEGIN_QUOTE
    Si repetimos la operación usando ~SELECT DISTINCT country FROM Customers~ obtendremos 
    sólo un registro con NULL, porque lo toma como un valor más
    #+END_QUOTE

    |-----------|
    | country   |
    |-----------|
    | argentina |
    | perú      |
    | bolivia   |
    | ~NULL~    |
    |-----------|
** GROUP BY Vs SELECT DISTINCT
*** Conceptos
    - Un ~SELECT DISTINCT col1~ filtra los registros duplicados de una columna específica
    - Un ~SELECT DISTINCT col1,col2,..~ filtra los registros duplicados de una combinación de varias columnas
    - El ~GROUP BY col1~ *agrupa según una columna* y NO muestra *grupos repetitivos* (/pongamos o no 1 ó varias columnas/)

    #+BEGIN_QUOTE
    Si usamos ~SELECT DISTINCT~ algunas variantes serían..

    1. Si hacemos ~SELECT DISTINCT col1 FROM Tabla~ es decir mostramos sólo 1 columna, 
    y sólo a esa le aplicamos ~DISTINCT~ entonces el resultado será registros sin repetir

    2. En cambio si hacemos ~SELECT DISTINCT col1, col2, col3 FROM Tabla~ donde mostramos 3 columnas,
    el ~DISTINCT~ actúa sobre las 3 columnas, y mostrará registros sin repetir entre la combinación
    de los datos entre ellas.
    Por lo cual puede llegar a repetirse datos de una o dos columnas, pero NO de las 3 columnas.
    #+END_QUOTE

    #+BEGIN_QUOTE
    Si usamos ~GROUP BY~  algunas variantes serían..

    1. Si ejecutamos ~SELECT col1, COUNT(col2) FROM Tabla GROUP BY col1~ agrupará por la primera columna
    evitando grupos repetidos (en función a la primera columna)
    y la cantidad de registros en donde la segunda columna tiene un valor, si tuviese NULL lo cuenta una única vez
    (/si hubiese registros donde el valor de la segunda columna se repite, los contará también/)
   
    2. Si realizamos ~SELECT col1, COUNT(DISTINCT col2) FROM Tabla GROUP BY col1~ mostrará la misma cantidad
    de registros que la anterior consulta, con la diferencia que sólo contará cuando el valor
    de la segunda columna sea diferente.
    Esto es útil por ej. si queremos agrupar por el nombre de un producto, y queremos saber la cantidad
    de clientes diferentes lo compraron, suponiendo que alguno de los clientes compraron varias veces el mismo producto,
    sólo contaríamos 1 vez por cada cliente.
    #+END_QUOTE

    #+BEGIN_QUOTE
    Diferencias???
    La diferencia entre si usar ~GROUP BY~ ó solo ~SELECT DISTINCT~ está en que si modificamos la query anterior así
    1. le sacamos el ~GROUP BY~ 
    2. le dejamos la *función de agregación* ~COUNT~
    3. usamos un ~SELECT DISTINCT~ 

    El resultado será TOTALMENTE DIFERENTE..!

    Probamos con ~SELECT DISTINCT col1, COUNT(col2) FROM Tabla~ el resultado será sólo 1 registro,
    donde el valor de la segunda columna será la cantidad total de registros de la tabla,
    y el valor de la primera NO TENDRÁ NINGUNA RELACIÓN con la segunda
    #+END_QUOTE
*** Ejemplos
**** Ejemplo 1
    #+BEGIN_SRC sql
      -- Mostramos los productos que tengan nombre diferente
      -- evitamos ver filas con nombre repetido
      --
      -- Diferencias con el GROUP BY:
      -- 1. La "función de agregación" count(*) hará que se muestre un sólo registro
      -- que es la cantidad de productos en total
      --
      -- 2. Mostrará en las dos primeras columnas ProductName y Price,
      -- el primer registro de ordenar la tabla por nombre de forma ascendente
      -- (no tiene relación alguna con el resultado del COUNT(), que muestra el total de productos)
      SELECT DISTINCT(ProductName), Price, count(*)
        FROM Products
       ORDER BY 1 ASC;

      -------------------------------------------------------------------------------------------------

      -- Agrupamos los productos por nombre y precio
      -- evitamos ver filas repetidas
      --
      -- Diferencias con el DISTINCT:
      -- 1. Mostrará cada producto sin repetir (porque lo agrupa por nombre y precio),
      -- y este COUNT(*) muestra en cada fila, la cantidad de veces que aparece repetido el producto
      SELECT ProductName, Price, count(*)
        FROM Products
       GROUP BY ProductName, Price
       ORDER BY 1;
    #+END_SRC
**** Ejemplo 2 - Select
     #+BEGIN_QUOTE
    ~SELECT ProductName, Quantity FROM OrderDetails ORDER BY 1 ASC, 2 ASC~
    Mostramos de los pedidos cada producto por nombre y cantidad
    #+END_QUOTE

    |-------------+----------|
    | ProductName | Quantity |
    |-------------+----------|
    | Manzana     | ~10~     |
    | Manzana     | ~10~     |
    | Manzana     | 15       |
    | Pera        | ~5~      |
    | Pera        | ~5~      |
    | Pera        | 20       |
    |-------------+----------|
**** Ejemplo 3 - Select con DISTINCT
     #+BEGIN_QUOTE
    ~SELECT DISTINCT ProductName, Quantity  FROM OrderDetails ORDER BY 1 ASC, 2 ASC~
    Mostramos de los pedidos cada producto por nombre y cantidad.
    Pero NO mostramos los que se repitan por nombre y cantidad
    #+END_QUOTE

    |-------------+----------|
    | ProductName | Quantity |
    |-------------+----------|
    | Manzana     |       10 |
    | Manzana     |       15 |
    | Pera        |        5 |
    | Pera        |       20 |
    |-------------+----------|
**** Ejemplo 4 - Select + Función de Agregación
    #+BEGIN_QUOTE
    ~SELECT ProductName, SUM(Quantity) Cantidad_total FROM OrderDetails ORDER BY 1~
    Mostramos de todos los pedidos la cantidad total de cada producto
    (no hay ninguna relación entre el nombre del producto con el total,
    aparece sólo un registro porque la "función de agregación" ~SUM()~ devuelve un resultado
    a menos.. que usemos ~GROUP BY~ y mostrará de cada producto)
    #+END_QUOTE

    |-------------+----------------|
    | ProductName | Cantidad_Total |
    |-------------+----------------|
    | Manzana     |             65 |
    |-------------+----------------|
**** Ejemplo 5 - Select + Distinct + Función de Agregación
    #+BEGIN_QUOTE
    ~SELECT DISTINCT ProductName, SUM(Quantity) Cantidad_total FROM OrderDetails ORDER BY 1~
    Vemos que con ó sin ~DISTINCT~ el resultado es el mismo,
    porque debemos agrupar los registros con ~GROUP BY~
    #+END_QUOTE
    |-------------+----------------|
    | ProductName | Cantidad_Total |
    |-------------+----------------|
    | Manzana     |             65 |
    |-------------+----------------|

**** Ejemplo 6 - Select + Función de Agregación
    #+BEGIN_QUOTE
    ~SELECT ProductName, COUNT(*) Cantidad_total FROM OrderDetails ORDER BY 1~

    Lo mismo que sucedía en el ejemplo anterior, no tiene relación el resultado del ~COUNT(*)~
    con el registro de la primera columna
    #+END_QUOTE

    |-------------+----------------|
    | ProductName | Cantidad_Total |
    |-------------+----------------|
    | Manzana     |              6 |
    |-------------+----------------|
**** Ejemplo 7 - Select + GROUP BY + Función de Agregación
    #+BEGIN_QUOTE
    ~SELECT ProductName, SUM(Quantity) Cantidad_total FROM OrderDetails GROUP BY ProductName ORDER BY 1~
    Al agrupar ahora si podemos ver de todos pedidos, cada producto y su cantidad total
    #+END_QUOTE
    |-------------+----------------|
    | ProductName | Cantidad_Total |
    |-------------+----------------|
    | Pera        | 30             |
    | Manzana     | 35             |
    |-------------+----------------|
**** Ejemplo 8 - Select + GROUP BY + Función de Agregación con DISTINCT
     Mostramos de todos los productos, cuantos clientes diferentes los compraron

     #+BEGIN_SRC sql
     SELECT ProductName, count(*), count(DISTINCT CustomerID)
     FROM Products p
     JOIN OrderDetails od ON p.ProductID = od.ProductID
     JOIN Orders o ON o.OrderID = od.OrderID
     GROUP BY ProductName
     #+END_SRC

     #+BEGIN_QUOTE
     La tabla sin el ~GROUP BY~ para ver la repetición de los registros con todas las columnas,
     observamos como los primeros 3 registros se repite la venta al mismo cliente,
     #+END_QUOTE

    |-----------+-------------+---------+----------+------------+----------|
    | ProductID | ProductName | OrderID | Quantity |  OrderDate | ClientID |
    |-----------+-------------+---------+----------+------------+----------|
    |         1 | Manzana     |     100 |       10 | 01-10-2009 | ~001~    |
    |         1 | Manzana     |     102 |       15 | 15-11-2010 | ~001~    |
    |         1 | Manzana     |     102 |       15 | 29-11-2011 | 002      |
    |-----------+-------------+---------+----------+------------+----------|

    #+BEGIN_QUOTE
    Cuando hagamos el ~COUNT(DISTINCT CustomerID)~ contará sólo dos registros,
    el motor los registros algo similar a esto
    #+END_QUOTE

    |-----------+-------------+----------|
    | ProductID | ProductName | ClientID |
    |-----------+-------------+----------|
    |         1 | Manzana     | ~001~    |
    |         1 | Manzana     | 002      |
    |-----------+-------------+----------|

    #+BEGIN_QUOTE
    Por lo tanto el resultado de la query del principio sería algo asi..
    ponemos las dos columnas con y sin ~DISTINCT~ para diferenciar el resultado,
    - la tercera columna muestra los registros repetidos (cosa que no queremos)
    - la cuarta columna muestra el resultado deseado
    #+END_QUOTE

    |-----------+-------------+----------+----------------------------|
    | ProductID | ProductName | count(*) | count(DISTINCT CustomerID) |
    |-----------+-------------+----------+----------------------------|
    |         1 | Manzana     |        3 |                          2 |
    |-----------+-------------+----------+----------------------------|
** [DOING] Atomicidad de Tablas (Al usar JOINs)
*** Conceptos
   #+BEGIN_QUOTE
   Si hacemos un ~JOIN~ entre tablas => debemos analizar el *tipo de relación* entre ellas
   (/Ej. Si la relación entre las tablas es 1 a 1 ó 1 a N/)

   Si NO chequeamos el *tipo de relación*
   - tendremos una cantidad de registros mayor ó menor a la que queríamos
   - tendremos errores de cálculo al usar *funciones de agregación* (/Ej. SUM, AVG, COUNT, .../)
   #+END_QUOTE
*** Ejemplo 1 - Código SQL
    #+BEGIN_SRC sql
      /*
        ,* Nota (1):
        ,* 1. Si partimos que nuestro dominio es "Facturas",
        ,* entonces el COUNT no necesita del "DISTINCT" ya que la relación
        ,* entre Factura-Cliente es 1 a 1, una factura puede pertenecer sólo
        ,* a un Cliente.
       ,*/
      SELECT factura_cliente,
             count(*) clientes_cant --> (1)
        FROM facturas
       GROUP BY factura_cliente;

      ---------------------------------------------------------------------
      /*
        ,* Nota (1)
        ,* 1. Como necesitamos saber la facturación total de cada venta,
        ,* asociamos cada factura con su renglón.
        ,* 2. Al estar agrupando por "factura_cliente" hacer COUNT(*)
        ,* nos daría un resultado incorrecto, por tener registros repetidos
        ,* por JOINear con renglon_factura que tiene mayor atomicidad que Facturas.
        ,* 3. Si hicieramos COUNT(factura_cliente) nos devolverá el valor 1,
        ,* porque estamos agrupando por ese campo, y no se repitirían.
        ,* 4. En el COUNT hacemos DISTINCT de la PK de Factura,
        ,* porque la relación entre Factura-Cliente es 1 a 1,
        ,* en el dominio de Facturas, ya que una factura pertenece sólo a 1 cliente
        ,*
        ,* Nota (2):
        ,* 1. Como la relación entre Factura y Renglon_Factura es 1 a N
        ,* afecta la atomicidad, y nos devuelve una mayor cantidad de registros
        ,* pero no afecta el resultado de AVG para calcular el promedio.
        ,* Pero si nos pidieran la suma total, tendriamos que usar SUM
        ,* y ahi veriamos un resultado incorrecto.
        ,*
        ,* Nota (3):
        ,* 1. Suponiendo que nos piden contar la cantidad productos comprados
        ,* que sean diferentes/distintos
        ,*
       ,*/
      SELECT factura_cliente,
             COUNT(DISTINCT f.letra+f.tipo) clientes_cant, --> (1)
             AVG(factura_total), --> (2)
             COUNT(DISTINCT rf.item_producto) --> (3)
        FROM facturas f
               JOIN renglon_factura rf ON rf.letra+rf.tipo = f.letra+f.tipo --> (1)
       GROUP BY factura_cliente;
    #+END_SRC
*** Ejemplo 2 - Descriptivo + Código SQL
    #+BEGIN_QUOTE
    Si queremos mostrar la descripción de todos los productos,
    seguido de la cantidad de clientes que los compraron,
    seguido del total vendido de ese producto..

    Veremos como la siguiente consulta devolverá un resultado INCORRECTO
    para la última columna, por no analizar el *tipo de relación* entre las tablas,

    ya que nos devolverá la cantidad de veces que se vendieron,
    y a esa cantidad se le agregará la cantidad que haya de ese producto en stock..
    #+END_QUOTE

    #+BEGIN_SRC sql
      /*
        Paso (1):
        digamos que "productos" devuelve 100 registros

        Paso (2):
        lo asociamos con cada renglón de las facturas
        que tiene mayor nivel de atomicidad entre "Facturas" y "item_Factura"
         y devolverá un producto cartesiano (PRODUCTOS x ITEM_FACTURA)
         pero sólo los que estén asociados a un item_factura

        Paso (3):
        asociamos los "item_factura" (renglones de las facturas) con las "facturas"
        devolverá la misma cantidad de registros, ni más ni menos
        porque la relación entre factura y item_factura es 1 a N,
        siendo item_factura el que mayor cantidad de registros tiene

        Paso (4):
        asociamos los "productos" con lo que tengamos en "stock"
        OJO..! La relación entre "stock" y "productos" es 1 a N, (stock puede tener muchos productos)
        por tanto hará otro producto cartesiano con "stock"

        y.. si hay muchos productos repetidos en "stock"
        entonces el cálculo de SUM(item_precio) SE HARÁ MAL! repetirá productos que estén en stock
       ,*/

      SELECT p.producto_descripcion, COUNT(DISTINCT f.cliente), SUM(item_precio)
        --> (Paso 1)
        FROM productos p
        --> (Paso 2)
               JOIN item_factura i ON p.producto_codigo = i.producto_codigo
        --> (Paso 3)
               JOIN facturas f ON f.factura_tipo+f.factura_numero = i.factura_tipo+f.factura_numero
        --> (Paso 4)
               JOIN stock s ON s.producto_codigo = p.producto_codigo
       GROUP BY p.producto_descripcion;
    #+END_SRC
** SQL Secuencialidad
   #+BEGIN_QUOTE
   Una forma de intepretar como SQL ejecuta las consultas de manera algorítmica sería
   1. Evalúa la tabla del ~FROM~ para tener el dominio, el conjunto de datos
   2. Filtra el conjunto del dominio/universo si hubiese un ~WHERE~
   3. Agrupa por columna si tuviese un ~GROUP BY~
   4. Filtra del los datos agrupados con ~HAVING~
   5. Ordena el conjunto

   Si hiciera un *producto cartesiano* se anidaría la tabla con otro for
   #+END_QUOTE
  
   #+BEGIN_SRC c
   for(not EOF Tabla) // iteraria sobre cada fila de la tabla del FROM
      if WHERE // filtraría por una o varias condiciones
                AAA // cada A sería un registro
  
   for(not EOF Tabla) // iteraría nuevamente por cada fila, y las agruparía según la columna de GROUP BY
      if HAVING // filtraría cada fila agrupada 
                BBB 

    ORDER BY (BBB)
   #+END_SRC
** Subquery correlacionada Vs JOIN
*** Conceptos
   #+BEGIN_QUOTE
   Cuando hacemos una *subquery correlacionada* en las columnas de ~SELECT~ es lo mismo que un ~JOIN~
  
   Es útil cuando queremos realizar una operación sobre todos los registros de una tabla
   pero el resultado de la *query principal* está afectada por un filtro por tanto no tenemos el total de los registros,
   y si tratasemos de aplicar una *funcion de agregación* (/Ej. SUM,COUNT,.../) el resultado podría no ser correcto

   Entonces una *subquery correlacionada* en las columnas del ~SELECT~ 
   hará la operación sobre todos los registros de la tabla indicada
   comparando cada registro de la *query principal* contra la tabla de la *subquery correlacionada*
   haciendo lo mismo que un ~JOIN~
   
   Debajo usaremos de ejemplo la query donde hablabamos sobre la *Atomicidad de las Tablas*
   donde debiamos analizar el *tipo de las relaciones* entre las tablas (/1 a 1, 1 a N/)
   antes de hacer ~JOINs~ para no tener una cantidad de registros de más ó de menos
   #+END_QUOTE
*** Ejemplo 1 - Implementación SQL
   #+BEGIN_SRC sql
     /*
       Paso (1):
       1. Esta subquery correlacionada, actúa como un JOIN, entre las tablas Productos y Stock.
       Es necesaria porque la relación entre Facturas-item_factura es 1 a N, y entre Stock-Producto es 1 a N,
       esto nos trae registros de productos repetidos,

       porque en una Factura puede tener 10 Productos, y en Stock quizás sólo hay 1 producto
       y cuando hagamos SUM(stock_cantidad) nos dará mal el resultado, sumará 11 veces el stock_cantidad
       de ese producto

       2. Opera por cada registro (producto) de la query principal,
       suma la cantidad de stock de cada producto, chequeando si está en la tabla "Stock"
       y luego lo agrega como valor en cada fila la tercera columna

       Paso (2):
       1. Necesitamos agregar la columna "producto_codigo" en el GROUP BY,
       porque la "subquery correlacionada" está usando una columna que no fue agrupada.

       2. Al usar las "funciones de agregación" y "group by" cada columna del SELECT
       debe estar agrupada para que la implementación del "GROUP BY" sepa con que columnas igualar

       3. Además que la relación entre item_factura y Productos es "1 a 1",
       pero el motor no lo entiende así (relacionado con la primera parte del paso 1)
      ,*/
     SELECT p.producto_descripcion, COUNT(DISTINCT f.cliente),
            --> (Paso 1) debajo está la subquery correlacionada
            (SELECT SUM(stock_cantidad) FROM stock s WHERE s.stock_producto = p.producto_codigo)
       FROM productos p
              JOIN item_factura i ON p.producto_codigo = i.producto_codigo
              JOIN facturas f ON f.factura_tipo+f.factura_numero = i.factura_tipo+f.factura_numero
              JOIN stock s ON s.producto_codigo = p.producto_codigo
       --> (Paso 2)
      GROUP BY p.producto_descripcion, p.producto_codigo;
   #+END_SRC
*** Ejemplo 2 - Estructuras
    Creamos las estructuras para los ejemplos

    #+BEGIN_SRC sql
      CREATE TABLE stock(
        stock_almacen INTEGER NOT NULL,
        stock_prod INTEGER NOT NULL,
        stock_cantidad INTEGER DEFAULT 0,
        PRIMARY KEY (stock_almacen, stock_prod)
      );

      CREATE TABLE productos(
        prod_codigo INTEGER NOT NULL PRIMARY KEY,
        prod_nombre CHAR(30),
        prod_precio DECIMAL(12,2) DEFAULT 0
      );

      CREATE TABLE combos(
        combo_producto INT NOT NULL,
        combo_componente INT NOT NULL,
        PRIMARY KEY (combo_producto, combo_componente),
        FOREIGN KEY (combo_producto) REFERENCES productos (prod_codigo)
      );

      INSERT INTO stock (stock_almacen, stock_prod, stock_cantidad) --> 16 registros
      VALUES
            (001, 001, 10), (001, 002, 10), (001, 003, 10), (001, 004, 10), --> almacen (1) -> {10 manzanas,10 zanahorias, 10 bananas, 10 calabazas }
            (002, 001, 10), (002, 002, 10), (002, 003, 10), (002, 004, 10), --> almacen (2) -> {10 manzanas,10 zanahorias, 10 bananas, 10 calabazas }
            (003, 001, 10), (003, 002, 10), (003, 003, 10), (003, 004, 10), --> almacen (3) -> {10 manzanas,10 zanahorias, 10 bananas, 10 calabazas }
            (004, 001, 10), (004, 002, 10), (004, 003, 10), (004, 004, 10); --> almacen (4) -> {10 manzanas,10 zanahorias, 10 bananas, 10 calabazas }

      INSERT INTO productos (prod_codigo, prod_nombre, prod_precio) --> 10 registros
      VALUES
            (001, 'manzana', 200), (002, 'banana', 150), --> ingredientes para licuado frutal ($350)
            (003, 'zanahoria', 100), (004, 'calabaza', 300), --> ingredientes para sopa de verduras ($400)
            (005, 'licuado frutal', 120), --> mas barato que cada ingrediente por separado ($120)
            (006, 'sopa de verduras', 150), --> mas barato que cada ingrediente por separado ($150)
            (007, 'licuado saludable', 200);

      INSERT INTO combos (combo_producto, combo_componente)
      VALUES --> 7 registros
        (005, 001), (005, 002), --> licuado frutal = {manzana, banana}
        (006, 003), (006, 004), --> sopa de verduras = {zanahora, calabaza}
        (007, 001), (007, 003), (007, 004); --> licuado saludable = {manzana, zanahoria, calabaza}
    #+END_SRC
*** Ejemplo 2 - Diagrama
    #+BEGIN_SRC plantuml :file img/joins-vs-subquery.png :exports results
      @startuml
      hide circle
      skinparam linetype ortho

      note as N1
      ,**Stock** (16 registros) "Clave Compuesta"

      Ponemos de ejemplo solo 4 productos para el almacen=1,
      pero hagamos de cuenta que tenemos 4 almacenes

      |= stock_almacen |= stock_prod | stock_cantidad |
      | 001             | 001         | 10            |
      | 001             | 002         | 10            |
      | 001             | 003         | 10            |
      | 001             | 004         | 10            |


      ,**Productos** (7 registros) "Clave Simple"
      |= codigo   | nombre            | precio |
      | 001       | manzana           | 200    |
      | 002       | banana            | 150    |
      | 003       | zanahoria         | 100    |
      | 004       | calabaza          | 300    |
      | **005**       | **licuado frutal**    | 120    |
      | **006**       | **sopa de verduras**  | 150    |
      | **007**       | **licuado saludable**  | 200    |

      ,**Combos** (7 registros) "Clave Compuesta"
      |= codigo_prod   |= codigo_componente |
      | 005           | 001               |
      | 005           | 002               |
      | 006           | 003               |
      | 006           | 004               |
      | 007           | 002               |
      | 007           | 003               |
      | 007           | 004               |
      endnote

      note as N2
      1. iteramos con un SELECT sobre la tabla Combos
      2. iteramos con el JOIN sobre Productos para asociar cada producto para ver si es un combo
      3. iteramos con otro JOIN sobre Productos para asociar que producto es un componente

      En (1) recorre 7 registros, en (2) y (3) recorre dos veces 10 registros..
      Terminará mostrando 7 registros, los que tiene los Combos,
      porque la **relación es 1 a 1** entre **producto.codigo_prod = combo.combo_producto**
      lo mismo para **producto.codigo_prod = combo.combo_componente**
      esto sucede porque la (PK) de Productos es una "clave simple" y la de Combos
      es una "Clave compuesta"

      <code>
      SELECT * FROM combos c
          JOIN productos p1 ON p1.prod_codigo = c.combo_producto
          JOIN productos p2 ON p2.prod_codigo = c.combo_componente
      </code>

      --
      ,**2) Query + 2 Joins**
      ,* Opción sugerida, evitar subqueries

      <code>
      SELECT  p1.prod_nombre combo_nombre, 
              SUM(p2.prod_precio) precio_sin_combo,
              p1.prod_precio precio_con_combo
        FROM combos c
               JOIN productos p1 ON p1.prod_codigo = c.combo_producto
               JOIN productos p2 ON p2.prod_codigo = c.combo_componente
       GROUP BY p1.prod_nombre
      </code>
      --
      ,**3) Query + JOIN + (Subquery correlacionada + Join)**
      ,* NO es muy eficiente, se puede evitar la subquery

      <code>
      SELECT 	prod_nombre, prod_precio precio_con_combo,
              (SELECT SUM(prod_precio) FROM productos p2
              JOIN combos c2 ON c2.combo_componente=p2.prod_codigo
              WHERE c2.combo_producto = c.combo_producto) precio_sin_combo
        FROM combos c
               JOIN productos p ON p.prod_codigo = c.combo_producto
       GROUP BY p.prod_nombre;
      </code>
      --

      Para las opciones (2) y (3) el resultado es el mismo

      | nombre                | precio_con_combo  | precio_sin_combo |
      | **licuado frutal**    | 120               | 350           |
      | **sopa de verduras**  | 150               | 400               |
      | **licuador saludable**  | 200               | 600               |


      endnote

      ''''''''''''''''''''''''''''''''''
      '' ENTIDADES

      ''''''''''''''''''''''''''''''''''
      '' RELACIONES


      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/joins-vs-subquery.png]]
*** Ejemplo 2 - Atomicidad (1)
    #+BEGIN_SRC sql
      --> 1) Probamos el nivel de atomicidad entre "Combos" y "Productos"
      --
      --> 1.1 La tabla "Combos" es la que mayor nivel de atomicidad tiene entre dichas tablas,
      --> porque su (PK) Clave Primaria es una "clave compuesta" formada por {combo_producto, combo_componente}
      --> por cada "combo" se va a repetir, porque hay mayor cantidad de combinaciones al ser una "clave doble"
      --
      --> 1.2. La tabla "Combos" permite más cantidad de combinaciones que "Productos"
      --> porque "Productos" sólo tiene una (PK) simple formada por {prod_codigo}
      --> por tanto no se puede repetir más de 1 vez en esa tabla "por la regla de integridad de entidad" (unicidad)
      --
      --> 1.3. cuando hagamos "SELECT * FROM Combos" y hagamos JOIN de "Productos" con la PK de Producto
      --> no importa que "Productos" tenga o no más registros que "Combos"
      --> porque la relación de la PK de Productos con Combos es "1 a 1" <--- combo.combo_producto = producto.codigo
      --> Ej. si combos tiene 2 registros, en el JOIN sólo se mostrarán 2 registros
      --> Ej. si combos tiene 4 registros, en el JOIN sólo se mostrarán 4 registros
      --> Ej. si combos tiene N registros, en el JOIN sólo se mostrarán N registros

      SELECT * FROM combos c --> devuelve 7 registros
                      JOIN productos p1 ON p1.prod_codigo = c.combo_producto --> se mantiene en 7 (relación 1 a 1)
                      JOIN productos p2 ON p2.prod_codigo = c.combo_componente;  --> se mantiene en 7 (relación 1 a 1)


      --> 2) Probamos con la tabla "Stock" que tiene una relación de "1 a N" con productos
      -->   y que además tiene una "clave compuesta" formada por {stock_almacen, stock_prod}
      -->   por tanto permite mayor cantidad de combinaciones al poder repetir el codigo de producto
      --
      --> 2.1 Veremos como con el JOIN con "stock" aumenta la cantidad de registros multiplicado por 4
      --> porque cada producto está repetido 4 veces, aunque en distintos almacenes de stock
      -->
      --> Ej. (almacen_1, productoA), (almacen_2, productoA), (almacen_3, productoA), (almacen_4, productoA), ...

      SELECT * FROM combos c --> 7 registros
                      JOIN productos p ON p.prod_codigo = c.combo_componente --> se mantiene en 7 registros
                      JOIN stock s ON s.stock_prod = p.prod_codigo; --> aumenta a 28 registros  (7*4 repeticiones en stock)
    #+END_SRC
*** Ejemplo 2 - Atomicidad (2)
    #+BEGIN_SRC sql
      /*
       ,* Nota (1):
       ,* Si hacemos un JOIN con stock asociando el codigo de producto
       ,* el resultado del SUM(p2.prod_precio) se ve afectado,
       ,* porque repite la cantidad de registros según cuantos haya en la tabla Stock
       ,*
       ,* Nota (2):
       ,* 1. Relacionamos el producto del combo, para obtener sus datos
       ,*
       ,* 2.Como la relación entre la PK de Productos y Combos es 1 a 1,
       ,* es decir por cada combo no habrá repetición de productos
       ,* Ej. {(combo_1, prod_1), (combo_1, prod_2), ...}
       ,*
       ,* por tanto es indistinto si usamos o no el DISTINCT,
       ,* es opcional el COUNT(DISTINCT p2.prod_codigo)
       ,*
       ,* Nota (3):
       ,* Es necesario volver a JOINear con Productos para saber el precio de c/componente
       ,* */
      SELECT
          p1.prod_nombre combo_nombre,
          SUM(p2.prod_precio) precio_sin_combo, --> (1)
          p1.prod_precio precio_combo, --> (3)
          COUNT(*) cant_productos --> (2)
          --,(SELECT SUM(stock_cantidad) FROM stock s WHERE stock_prod=c.combo_componente) cantidad_en_stock
        FROM combos c
               JOIN productos p1 ON p1.prod_codigo = c.combo_producto --> (2)
               JOIN productos p2 ON p2.prod_codigo = c.combo_componente --> (3)
               --JOIN stock s ON s.stock_prod = p2.prod_codigo --> (1)
       GROUP BY p1.prod_nombre, p1.prod_precio --,c.combo_componente
       ORDER BY 1
    #+END_SRC
*** Ejemplo 2 - Atomicidad (3)
    #+BEGIN_SRC sql
       /*
        ,* Nota 4:
        ,* 1. Al hacer JOIN con Stock se multiplica la cantidad de registros porque la relación
        ,* entre Stock y Productos es 1 a N, ya que sólo JOINeamos con la clave de Producto "prod_codigo"
        ,* pero como Stock tiene una "clave doble" (compuesta) le falta la otra parte de la clave
        ,* que es stock_almacen. Por lo que aparecerán productos repetidos.
        ,*
        ,* 2. Por ese motivo usamos el DISTINCT en el COUNT() de los productos que se repitan en el mismo combo
        ,* a causa del JOIN con Stock. Dejamos comentado uno sin DISTINCT para ver la diferencia.
        ,*
        ,* Nota 5:
        ,* 1. Similar al (4) al haber registros repetidos, se sumarán los precios por cada producto repetido
        ,* a diferencia del COUNT() no podemos usar un DISTINCT
        ,* 2. Si usamos este SUM como está, el resultado NO será correcto
        ,*
        ,* Nota 6:
        ,* 1. La subquery actúa como un JOIN
        ,* 2. Al usar "funciones de agregación" necesitamos agrupa por GROUP BY
        ,* y por el hecho de agrupar, debemos agregar "p2.prod_codigo" que usamos en la subquery correlacionada
        ,* como columna en el GROUP BY
        ,* */
       SELECT
          p1.prod_nombre,
          COUNT(DISTINCT p2.prod_nombre) productos_cant, --,COUNT(*) --> (4)
          p1.prod_precio combo_precio,
          SUM(stock_cantidad) stock_productos
          --SUM(p2.prod_precio) precio_sin_combo --> (5)
          --(SELECT SUM(prod_precio) FROM productos WHERE prod_codigo=p2.prod_codigo) precio_sin_combo --> (6)
        FROM combos c
               JOIN productos p1 ON p1.prod_codigo = c.combo_producto --> (2)
               JOIN productos p2 ON p2.prod_codigo = c.combo_componente --> (3)
               JOIN stock s ON s.stock_prod = p2.prod_codigo --> (1) (4)
        GROUP BY p1.prod_nombre, p1.prod_precio --, p2.prod_codigo
       ORDER BY 1
    #+END_SRC
*** Ejemplo 2 - Joins Vs Subquery Correlacionada
    #+BEGIN_SRC sql
      --> 1) Query + JOIN + (Subquery correlacionada + JOIN)
      --> Se puede evitar esa subquery, usando otro JOIN
      SELECT 	prod_nombre, prod_precio precio_con_combo,
              (SELECT SUM(prod_precio)
                 FROM productos p2
                        JOIN combos c2 ON c2.combo_componente=p2.prod_codigo
                WHERE c2.combo_producto = c.combo_producto) precio_sin_combo
        FROM combos c
               JOIN productos p ON p.prod_codigo = c.combo_producto
       GROUP BY p.prod_nombre;


      --> 2) Query + 2 Joins
      SELECT p1.prod_nombre combo_nombre, SUM(p2.prod_precio) precio_sin_combo, p1.prod_precio precio_con_combo
        FROM combos c
               JOIN productos p1 ON p1.prod_codigo = c.combo_producto
               JOIN productos p2 ON p2.prod_codigo = c.combo_componente
       GROUP BY p1.prod_nombre
    #+END_SRC
* Operador INSERT
** Inserción unitaria
  #+BEGIN_SRC sql
    -- "INTO" es opcional, cuando queremos definir las columnas
    -- podemos alterar el orden de las columnas
    INSERT INTO tabla (col1, col2, ..., coln)
    VALUES (valor1, valor2, ..., valorn);

    -- Si sólo queremos insertar los valores
    -- debemos respetar el orden de las columnas
    -- de la definición de la tabla
    INSERT tabla VALUES (valor1, valor2, ..., valorn)
  #+END_SRC
** Inserción masiva
* Operador DELETE
  #+BEGIN_SRC sql
    -- el "FROM" es opcional
    -- (aunque depende del motor)
    DELETE FROM tabla
     WHERE condicion;

    DELETE tabla
     WHERE condicion;
  #+END_SRC
* Operador SELECT
** Estructura
   #+BEGIN_SRC sql
     SELECT * -- lista de columnas
     FROM tabla -- tabla o lista de tablas
     WHERE condiciones_filtros
     GROUP BY columnas_de_agrupamiento
     HAVING condiciones_sobre_lo_agrupado
     ORDER BY columnas_clave_de_ordenamiento
   #+END_SRC
** Alias de Columnas
   - También se conocen como *etiquetas*

   #+BEGIN_SRC sql
     -- precioConIva es el alias
     -- en el resultado de la consulta aparecerá esa columna
     SELECT num_prod, precio*0.21 as precioConIva
     FROM products
   #+END_SRC
** Concatenar columnas
   Utilizamos el operador ~+~ (suma)

   #+BEGIN_SRC sql
     SELECT c.dni, c.nombre+ ', ' +c.apellido
     FROM clientes as c
   #+END_SRC
* WHERE - Condiciones
  Se agregan en el WHERE

  |-------------------------+------------------------------------------|
  | Condiciones             | Descripcion                              |
  |-------------------------+------------------------------------------|
  | =, !=, <>, <, <=, >, >= | operadores relacionales, de igualdad, .. |
  |-------------------------+------------------------------------------|
  | AND, OR, NOT            | Operadores lógicos                       |
  |-------------------------+------------------------------------------|
  | [NOT] LIKE              | Para validar cadenas                     |
  | [NOT] BETWEEN           | Para rangos                              |
  | [NOT] IN                | Saber si está una lista de valores       |
  | IS [NOT] NULL           |                                          |
  |-------------------------+------------------------------------------|
** Operadores Logicos/Relaciones/Otros
  #+BEGIN_SRC sql
    SELECT * FROM products as p
    WHERE p.price >= 100 AND p.price < 500;

    SELECT * FROM products as p
    WHERE p.price BETWEEN 100 AND 500;

    SELECT * FROM products as p
    WHERE p.category IN (1,4,9)
  #+END_SRC
** Operador LIKE
   Validar cadenas de caracteres, conceptualmente similar a las regexp
   aunque sintáticamente diferente

   |-------------------------------+------------------------------------------------------|
   |                               | Descripción                                          |
   |-------------------------------+------------------------------------------------------|
   | apellidoColumna LIKE 'A%'     | Apellidos que empiecen con A                         |
   | apellidoColumna LIKE '%sh%'   | Apellidos que contengan la palabra sh                |
   | apellidoColumna LIKE 'A_ _ _' | Apellidos que empiecen con A seguido de 3 caracteres |
   |                               | (sin los espacios, se agregan a modo de ejemplo)     |
   | apellidoColumna LIKE '[AEO]%' | Apellidos que empiecen con A ó con E ó con O         |
   | apellidoColumna LIKE '[A-O]%' | Apellidos que empiecen entre la A y la O             |
   |-------------------------------+------------------------------------------------------|

  #+BEGIN_QUOTE
  elegimos cualquier palabra que empiece con A
  seguido de cero o mas caracteres (actúa como clausula de kleene, comodin)
  ~LIKE 'A%'~

  palabras que contengan th en cualquier lado
  ~LIKE '%th%'~

  palabras que comiencen con A y contenga 4 letras (incluyendo la A)
  cada guión bajo repesenta cada caacter
  ~LIKE 'A_ _ _'~

  que comience con A ó E, 
  seguido de cero o mas caracteres
  ~LIKE '[AE]%'~

  que comience con caracteres entre A y E,
  seguido de cero o mas caracteres
  ~LIKE '[A-E]%'~
  #+END_QUOTE
   
   *Observación:*
   El símbolo ~%~ (porcentaje) actúa como el comodín de las regexp osea como la
   *clausula de kleene*. Es decir % representa cero o más caracteres
* ORDER BY - Ordenamiento
** Conceptos
  - Ordena por columna los resultados
  - Podemos ordenar de manera
    - ascendente (por default) {1,2,3,4...}
    - ó descendente {10,9,8,...}
  - Podemos ordenar por
    - nombre de columna
    - número de columna

  *Observación:*
  Se pueden ordenar las columnas que estén o no en el ~SELECT~
  (Ej. ~SELECT col1,col2 FROM tabla ORDER BY col3~)
** Ejemplos
  #+BEGIN_SRC sql
    -- Ordenamos por nombre de columna
    SELECT dni, nombre, apellido
    FROM clientes
    ORDER BY nombre, apellido;

    -- Ordenamos por la columna 2 y 3
    SELECT dni, nombre, apellido
    FROM clientes
    ORDER BY 2, 3;

    -- ordenar el resultado por columnas
    -- de forma descendente
    SELECT *
      FROM clientes
     ORDER BY ciudad, apellido DESC;

    -- con DISTINCT
    -- listamos valores unicos
    -- (elimina registros repetidos)
    SELECT DISTINCT
      FROM clientes
     ORDER BY ciudad, apellido DESC;
  #+END_SRC
* DISTINCT - Registros Repetidos
  - Utilizamos el operador *distinct* para evitar repetición de registros
  - Es útil cuando hacemos un ...

  #+BEGIN_SRC sql
    -- no repite los registros que tengan la columna "numero" repetida
    SELECT DISTINCT p.numero, p.nombre
    FROM productos as p
    ORDER BY 1; -- ordena por la primera columna (osea columna llamada numero)
  #+END_SRC
* Funciones Agregadas
*** Conceptos
    - Son funciones que dado un conjunto de datos (uno o más registros)
      realizan *operaciones agregadas*
    - Se utilizan bastante en conjunto con operador *GROUP BY* y *HAVING*
    
    *Observación:*
    NO se pueden anidar *funciones de agregación*
    (/Ej. Sintácticamente estaría mal poner MAX(SUM(col)), MIN(SUM(col))/)

    |-------------------------+-----------------------------------------------------------------------|
    | Funcion Agregada        | Descripción                                                           |
    |-------------------------+-----------------------------------------------------------------------|
    | SUM(columna)            | Suma el valor de esa columna (de cada registro)                       |
    | COUNT(*)                | Cuenta la cantidad total de registros                                 |
    | MIN(columna)            | Encuentra el valor mínimo de la columna                               |
    | MAX(columna)            | Encuentra el valor máximo de la columna                               |
    | AVG(columna)            | Calcula un valor promedio de la columna por el valor de cada registro |
    |-------------------------+-----------------------------------------------------------------------|
    | COUNT(columna)          | Cuenta la cantidad de registros de esa columna (no nulos)             |
    |-------------------------+-----------------------------------------------------------------------|
    | COUNT(DISTINCT columna) | Cuenta la cantidad de registros (no cuenta los que se repitan)        |
    |-------------------------+-----------------------------------------------------------------------|
*** Ejemplos
   #+BEGIN_SRC sql
     -- con todos estos queries
     -- solo va a mostrar las columnas

     SELECT COUNT(DISTINCT cliente_num)
       FROM clientes;

     SELECT COUNT(cliente_num)
       FROM clientes;

     SELECT MAX(pedido_fecha)
       FROM clientes;

     SELECT MAX(pedido_fecha) ultimaCompra,
            MIN(pedido_fecha) primerCompra
       FROM clientes;
   #+END_SRC
* Cláusula GROUP BY
  - Se suelen complementar con las [[Funciones Agregadas][funciones agregadas]]
  - La [[Cláusula Having][cláusula HAVING]] actúa como el where con el select

  #+BEGIN_SRC sql
    SELECT p.numero_pedido, count(*) as cantidad
    GROUP BY p.numero_pedido -- los agrupa por el numero pedido
    ORDER BY 1; -- ordena de forma ascendente por la primera columna (osea numero_pedido)

    SELECT p.numero_pedido, YEAR(p.fecha_pedido), MONTH(p.fecha_pedido)
    FROM pedidos as p
    GROUP BY YEAR(p.fecha_pedido), MONTH(p.fecha_pedido);
  #+END_SRC
* Cláusula HAVING
** Conceptos
   - Actúa en la cláusula [[Cláusula GROUP BY][GROUP BY]] como el where con el select, PERO con el ~GROUP BY~
   - Requiere de condiciones con [[Funciones Agregadas][funciones agregadas]]

   #+BEGIN_SRC sql
     SELECT p.numero_pedido, count(*) as cantidad
     GROUP BY p.numero_pedido
     HAVING count(*) >= 5 -- filtra por los que se repitan 5 ó mas veces
     ORDER BY 1;

     SELECT p.numero_pedido, YEAR(p.fecha_pedido), MONTH(p.fecha_pedido)
     FROM pedidos as p
     GROUP BY YEAR(p.fecha_pedido), MONTH(p.fecha_pedido);
   #+END_SRC
** Ejemplos
  EL having actua como el where con select, PERO CON group by

  #+BEGIN_SRC sql
    SELECT YEAR(order_date) anio,
           MONTH(order_date) mes,
           COUNT(order_date) cant
      FROM pedidos
      GROUP BY YEAR(order_date);
  #+END_SRC
* Ejemplos
  #+BEGIN_SRC sql
    -- is null
    -- NO hay que igualar a null
    select * from tabla IS NULL;

    -- para elegir entre un rango de numeros
    select * FROM tabla
     WHERE order_num between 10 AND 100;

    -- alternativa al between
    select * FROM tabla
     WHERE order_num >= 10 AND order_num <= 100;

    -- elegimos valores que sean alguno de esos tres
    SELECT * FROM tabla
     WHERE order_num IN (10,15,20);

    -- alternativa al IN() aunque no sería eficiente
    -- SELECT * FROM tabla
    -- WHERE order_num = 10 OR order_nu = 15 OR order_num = 20;

    -- el % reemplaza cero o mas caracteres (sería la clausula de kleene)
  #+END_SRC
* Parte práctica
  #+BEGIN_SRC sql
    -- ej. 3
    select distinct city
      from cliente
     where state ='ca'
     order by city;

    -- ej 5
    select fname, lname, c.address1, c.address2
      from customer c whee customer_num =103;

    -- ej. 6
    select p.stock_num, p.unit_price, p.unite_code
             from products_p
     where p.manu_code ='ANZ'
     order by p.unite_code;

    -- ej. 7
    select distinct manu_code
      from items
     order by 1;

    -- ej. 8
    select o.order_num, o.order_date, o.customer_num,
           o.ship_date
      from order o
     where o.paid_state is null
       and o.ship_date >= '2015-01-01'
       and o.ship_date < '2015-07-01'
           oder by 1;
    -- otra alternativa al anterior
    select order_num, order_date, customer_num, ship_date
      from order
     where paid_date
           IS NULL
           and year(ship_date) =2015
           and month(ship_date) between 1 and 6;
    -- ej. 9
    select c.customer_num, c.company
             from customer c
             where c.company like '%town%';
      -- ej. 10
    select max(o.ship_charge) maximo,
           min(o.ship_charge) minimo,
           avg(o.ship_charge) promedio
             from orders o;
    -- ej 11
    select o.order_num, o.ode_date, o.ship_date
     from orders o
     where year(o.ship_date) = year(o.order_date)
     and month(o.ship_date) = month(o.order_date);

    -- ej 12
    -- SIEMPRE LO QUE AGREGEMOS EN GROUP BY
    -- debe figurar en el SELECT
    --
    -- si NO agregamos una columna en el group by
    -- lanza error
    select o.customer_num, o.ship_date, count(*),
           sum(o.ship_charge) total,
     from orders o
     group by o.customer_num, o.ship_date
     order by total desc;

    -- ej 13
    select o.ship_date, sum(o.ship_weight) pesoTotal
      from orders o
     group by o.ship_date
    having sum(o.ship_weight) >= 30
           order by pesoTotal DESC;
  #+END_SRC
* Preguntas resueltas
** Pregunta (1)
   #+BEGIN_QUOTE
   que admita ~NULL~, es lo mismo que en el DER aparezca modalidad opcional?
   si por default todos son ~NOT NULL~, en el DER serian todos modalidad obligatoria? 
   #+END_QUOTE

   *Respuesta*: Si en ambos
