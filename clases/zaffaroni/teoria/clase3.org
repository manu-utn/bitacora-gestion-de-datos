#+TITLE: Clase 03 - DML - Implementar Dominio

y que admita null, es lo mismo que en el DER aparezca modalidad opcional?
 si por default todos son not null, en el DER serian todos modalidad obligatoria? 
no genera problemas crear un registro que haga referencia a otro que aun 
no existe o como se resolveria eso?

* Tablas
  - unidad basica para almacenamiento datos
* Constraints
  - son las restricciones
** Integridad semantica
   - data type
   - default
   - unique
   - not null
   - check
** self referencing constraint
   cuando se hace referencia a si mismo
   FOREIGN KEY (n_jefe) references empleados (n_empleado)
** default
   las columnas no nombradas en el INSERT()
   les dará un valor por defecto que pongamos al definir la tabla
** unique
   para claves alternas (las claves que son posibles PK)
   se deberia de complementar con el constraint NOT NULL
** check constraint   
* SQL
** ddl
   - data definition language 
     (Ej. alter table, drop table, ...)
   - para definir los datos
** dml
   - data manipulation language
   (eJ. select, inset, update, delete)
   - para manejar los datos
** Operador select
   #+BEGIN_SRC sql
     -- is null
     -- NO hay que igualar a null
     select * from tabla IS NULL;

     -- para elegir entre un rango de numeros
     select * FROM tabla
      WHERE order_num between 10 AND 100;

     -- alternativa al between
     select * FROM tabla
      WHERE order_num >= 10 AND order_num <= 100;

     -- elegimos valores que sean alguno de esos tres
     SELECT * FROM tabla
      WHERE order_num IN (10,15,20);

     -- alternativa al IN() aunque no sería eficiente
     -- SELECT * FROM tabla
     -- WHERE order_num = 10 OR order_nu = 15 OR order_num = 20;

     -- el % reemplaza cero o mas caracteres (sería la clausula de kleene)
   #+END_SRC

   #+BEGIN_EXAMPLE
   elegimos cualquier palabra que empiece con A
   seguido de cero o mas caracteres (actúa como clausula de kleene, comodin)
   LIKE 'A%'

   palabras que contengan th en cualquier lado
   LIKE '%th%'

   palabras que comiencen con A y contenga 4 letras (incluyendo la A)
   cada guión bajo repesenta cada caacter
   LIKE 'A_ _ _'

   que comience con A ó E, 
   seguido de cero o mas caracteres
   LIKE '[AE]%'

   que comience con caracteres entre A y E,
   seguido de cero o mas caracteres
   LIKE '[A-E]%'
   #+END_EXAMPLE
** Order by
   ordena por columna los resultados

   #+BEGIN_SRC sql
     -- ordenar el resultado por columnas
     -- de forma descendente
     SELECT *
       FROM clientes
      ORDER BY ciudad, apellido DESC;

     -- con DISTINCT
     -- listamos valores unicos
     -- (elimina registros repetidos)
     SELECT DISTINCT
       FROM clientes
      ORDER BY ciudad, apellido DESC;
   #+END_SRC
** [TODO] Funciones agregadas
   #+BEGIN_SRC sql
     -- con todos estos queries
     -- solo va a mostrar las columnas

     SELECT COUNT(DISTINCT cliente_num)
       FROM clientes;

     SELECT COUNT(cliente_num)
       FROM clientes;

     SELECT MAX(pedido_fecha)
       FROM clientes;

     SELECT MAX(pedido_fecha) ultimaCompra,
            MIN(pedido_fecha) primerCompra
       FROM clientes;
   #+END_SRC
** Group by y Having
   EL having actua como el where con select, PERO CON group by

   #+BEGIN_SRC sql
     SELECT YEAR(order_date) anio,
            MONTH(order_date) mes,
            COUNT(order_date) cant
       FROM pedidos
       GROUP BY YEAR(order_date);
   #+END_SRC

* parte practica
  #+BEGIN_SRC sql
    -- ej. 3
    select distinct city
      from cliente
     where state ='ca'
     order by city;

    -- ej 5
    select fname, lname, c.address1, c.address2
      from customer c whee customer_num =103;

    -- ej. 6
    select p.stock_num, p.unit_price, p.unite_code
             from products_p
     where p.manu_code ='ANZ'
     order by p.unite_code;

    -- ej. 7
    select distinct manu_code
      from items
     order by 1;

    -- ej. 8
    select o.order_num, o.order_date, o.customer_num,
           o.ship_date
      from order o
     where o.paid_state is null
       and o.ship_date >= '2015-01-01'
       and o.ship_date < '2015-07-01'
           oder by 1;
    -- otra alternativa al anterior
    select order_num, order_date, customer_num, ship_date
      from order
     where paid_date
           IS NULL
           and year(ship_date) =2015
           and month(ship_date) between 1 and 6;
    -- ej. 9
    select c.customer_num, c.company
             from customer c
             where c.company like '%town%';
      -- ej. 10
    select max(o.ship_charge) maximo,
           min(o.ship_charge) minimo,
           avg(o.ship_charge) promedio
             from orders o;
    -- ej 11
    select o.order_num, o.ode_date, o.ship_date
     from orders o
     where year(o.ship_date) = year(o.order_date)
     and month(o.ship_date) = month(o.order_date);

    -- ej 12
    -- SIEMPRE LO QUE AGREGEMOS EN GROUP BY
    -- debe figurar en el SELECT
    --
    -- si NO agregamos una columna en el group by
    -- lanza error
    select o.customer_num, o.ship_date, count(*),
           sum(o.ship_charge) total,
     from orders o
     group by o.customer_num, o.ship_date
     order by total desc;

    -- ej 13
    select o.ship_date, sum(o.ship_weight) pesoTotal
      from orders o
     group by o.ship_date
    having sum(o.ship_weight) >= 30
           order by pesoTotal DESC;
  #+END_SRC
* kahoot
** Pregunta 1
   *Pregunta:*
   SELECT nombre FROM empleados WHERE apellido LIKE '[A-G]_ _%'

   *Respuesta:*
   apellidos que comienzan entre A y G, 
   con 3 o más letras
   
   *Justificación:*
   el [A-G] se usa para rangos de valores
   el _ representa cualquier caracter (uno solo)
   el % representa la clausura de kleene, 1 o más veces cualquier caracter
** Pregunta 2
   *Pregunta:*
   SELECT nombre, apellido lname FROM empleados
   la sintáxis es correcta? V/F
   
   *Respuesta:*
   Verdadero
   
   *Justificación:*
   A primera vista puede parecer que falta una coma entre
   apellido y lname, pero.. ~lname~ es un *alias*

   es como si hubiera puesto ~apellido as lname~
** Pregunta 3
   *Pregunta:*
   Orden correcto de las clausulas del select
   a) SELECT - FROM - GROUP BY - ORDER BY ?
   b) SELECT - FROM - ORDER BY - WHERE ? 
   c) SELECT - WHERE - FROM - ORDER BY ? 
   d) SELECT - FROM - ORDER BY - GROUP BY ?
   
   *Respuesta:*
   a) SELECT - FROM - GROUP BY - ORDER BY
   
   *Justificación:*
   la b) porque... el ORDER BY, va al final
   la c) porque.. el FROM va antes que el WHERE
   la d) está al porque primero se agrupan los datos con GROUP BY,
   y luego los ordena con ORDER BY
** Pregunta 4
   *Pregunta:*
   cual es un SELECT VALIDO
   a) SELECT * WHERE apellido='gomez'
   b) SELECT apellido, nombre WHERE apellido='Gomez'
   c) SELECT codigo FROM empleados ORDER BY apellido WHERE
      apellido='gomez'
   d) SELECT apellido, nombre FROM empleados ORDER BY apellido
   
   *Respuesta:*
   d) SELECT apellido, nombre FROM empleados ORDER BY apellido
   
   *Justificación:*
   la a) le falta el FROM
   la b) le falta el FROM
   la c) el ORDER BY va al final
** Pregunta 5
   *Pregunta:*
   La condición (x>=10 AND X<=20) es igual a (x BETWEEN 10 AND 20)
   V/F?
   
   *Respuesta:*
   Verdadero
