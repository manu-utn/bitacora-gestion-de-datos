#+TITLE: Clase 05 - Join

#+BEGIN_COMMENT
  1. Pagina 10,11,14 - Views
  2. Pagina 28 - Joins, se podría haber usado ~GROUP BY~ ?
  3. [[DUDA 1]]
  4. Una *columna virtual* representan operaciones calculadas
     que se le agregan alias? SI
  5. Pag. 38, como es que se pueden borrar filas si tiene 
     columnas virtuales?
  6. Pag. 28. cuál sería el resultado si en vez de JOIN
     usaramos solo la cláusula ~WHERE~ ?
#+END_COMMENT
* Ejemplos de clase
  
  #+BEGIN_SRC sql
    SELECT c1.customer_num, c1.lname+', '+c1.fname Cliente_padre_Referente,
           c2.customer_num, c2.lname+', '+c2.fname Cliente_hijo_Referido
      FROM customer c1 JOIN customer c2 
                           ON (c1.customer_num = c2.customer_num_referedBy);

    select * from customer where customer_num in (102,103);

    --------------------------------------------------------------------

    DROP VIEW v_totalesordenes2
      CREATE VIEW v_totalesOrdenes2
      (Codcli, ape, nom, cantOC, total)
      AS
      SELECT c.customer_num,lname,fname, COUNT(DISTINCT o.order_num), SUM(quantity*unit_price) totalComprado
      FROM customer c JOIN orders o ON o.customer_num=c.customer_num
      JOIN items i ON o.order_num = i.order_num
      GROUP BY c.customer_num,lname,fname;

      select * from v_totalesOrdenes2;
      ------------------------------------------------------------------

      select * from items i  join orders o  on (o.order_num=i.order_num) where customer_num=104;
  #+END_SRC
* Vista - Views
** Conceptos
  =<<DUDA 1>>: columnas virtuales, se refiere a columnas de otra View?=
*** Que representa
    - Conjunto de columnas *reales* ó *virtuales* de una o varias tablas
    - Representa los datos de una o más tablas ó de otras vistas
    - Está definida por una consulta (en una o más tablas)
      - Puede tener filtros << Importante
*** No aloca espacio
    NO ocupa espacio de almacenamiento (sólo metadata)
*** Seguridad
    Restringe el acceso a determinadas filas/columnas de una tabla
*** Oculta Complejidad 
    Simplifica las sentencias al usuario
    (evitando hacer queries largas ó complejas)
** Restricciones
*** Indices
    NO se pueden crear *índices*
*** Dependen de las tablas
    Dependen de las tablas a las que hace referencia
     - Siendo *eliminadas* si esas tablas se borraron
     - Quedando *inválidas* si se borraron las tablas
     - Se pueden borrar/agregar/modifica a las tablas que hace referencia
*** Restricción de operaciones Insert/Delete/Update
    Si se utilizó ~JOIN~ ó ~TRIGGERS~ una *funciòn agregada*
    NO se podrán utilizar operaciones
    + insert
    + delete
    + update

    *Observación:*
    Las *funciones agregadas* son ~COUNT, SUM, MAX, MIN, AVG~
    aquellas que operan un conjunto de datos, y devuelven 
    un solo resultado
*** Clausulas ORDER BY y UNION
    NO se pueden utilizar las cláusulas ~ORDER BY~ y ~UNION~
*** With Check Option
    - Realiza un *chequeo de integridad de los datos* a insertar/modificar
    - Impide que se inserten/modifiquen MAL los registros, los valida
    - Al modificar/insertar se debe cumplir las condiciones
      de la clásula ~WHERE~ definida en la *view*
** Implementacion
*** Ejemplo 1 - Insertar registros
   #+BEGIN_SRC sql
     -- con "WITH CHECK OPTION"
     -- restringimos los insert/update/delete,
     -- sólo a los que cumplan la condición del WHERE
     CREATE VIEW v_clientes_brasil (codigo, apellido, nombre, pais)
       AS
       SELECT codigo_cliente, apellido, nombre
         FROM clientes
        WHERE pais='BR'
              WITH CHECK OPTION;

     -- lo siguiente FALLARÁ..! y NO se insertará el registro
     -- porque NO cumple con la condición de la clásula WHERE pais='BR
     -- de la vista v_clientes_brasil
     INSERT INTO clientes (codigo, apellido, nombre, pais)
     VALUES (99, 'fernandez', 'carlos', 'UK');
   #+END_SRC
*** Ejemplo 2 - Actualizar registros
    #+BEGIN_SRC sql
      -- con "WITH CHECK OPTION"
      -- restringimos los insert/update/delete,
      -- sólo a los que cumplan la condición del WHERE
      CREATE VIEW v_clientes_brasil (codigo, apellido, nombre, pais)
        AS
        SELECT codigo_cliente, apellido, nombre
          FROM clientes
         WHERE pais='BR'
               WITH CHECK OPTION;

     -- lo siguiente FALLARÁ..! y NO se actualizará el registro
     -- porque NO cumple con la condición de la clásula WHERE pais='BR'
     -- de la vista v_clientes_brasil pais='BR'
      UPDATE v_clientes_brasil
         SET pais = 'UK'
       WHERE codigo=99;
    #+END_SRC
*** Ejemplo 3
    #+BEGIN_SRC sql
      DROP VIEW totalOrdenes;

      CREATE VIEW totalOrdenes (cod, ape, nom, cant, total)
        AS SELECT c.customer_num, SUM(quantity*unit_price) totalComprado
             FROM customer c
                    JOIN orders o ON o.customer_num=c.customer_num
                    JOIN items i ON o.order_num = i.order_num
                    -- importante usar el group by
                    -- porque estamos usando funciones SUM() agrupacion (???)
                    -- o eran agregadas (?)
                    GROUP BY c.customer_num, lname, fname;

      SELECT * FROM totalOrdenes;
    #+END_sRC
* Snapshots - Materialized Views
  + Similar a una *View* pero ocupan espacio en disco
  + Son objetos del esquema de una DB
  + Permite *mostrar operaciones calculadas de manera rápida*
  + Muestra una *captura de un instante dado*, 
  + si se actualizan los datos de las tablas maestras,
     las Snapshot se deben crear nuevaente
* DML - Data Manipulation Language
** Conceptos DML
   + Es una Categoria que incluye a comandos/instrucciones que manipulan datos
   + SQL (Structured Query Language) es un lenguaje para manipular datos (DML)
   + Las instrucciones que ofrece SQL para DDL son
     * SELECT
     * INSERT
     * DELETE
     * UPDATE

   *Observación:*
   - En otras biografías mencionan que ~SELECT~ está en la categoría 
     de *(DQL, Data Query Language)* 
** SELECT
*** JOIN
    Usamos la instrucción ~JOIN~ si queremos hacer *coincidir* (MATCH) filas 
    de dos o más tablas a partir de un atributo con valores comunes

    #+BEGIN_EXAMPLE
    Si a partir de una tabla PEDIDOS,
    queremos los nombres y apellidos de la tabla CLIENTES

    asociamos la FK codCliente de PEDIDOS
    con la PK codCliente de CLIENTES

    asi obtendremos sólo los clientes que hicieron al menos un pedido
    #+END_EXAMPLE
*** Inner JOIN
**** Conceptos
     + El ~INNER JOIN~ sólo devuelve las filas que coincidan (que *MACHEEN*)
     + El ~INNER~ es opcional, porque lo usa defecto el ~JOIN~
       (si no lo agregamos, lo usará igual por detrás)
     + Usamos los *alias* de tabla, en las columnas que se repitan
       entre las otras tablas que hacemos ~JOIN~
**** Ejemplo 1 - Con una clave simple
     Usamos sólo un atributo para evaluar que filas coinciden
     en este caso solo es ~cliente_num~
    
    #+BEGIN_SRC sql
      SELECT c.codigo, nombre, apellido
        FROM cliente c
        INNER JOIN ordenes o
        ON (c.cliente_num = o.cliente_num);
    #+END_SRC
**** Ejemplo 2 - Con una Clave compuesta
     - Usamos los operadores lógicos AND, OR, para armarlas
     - Usamos los *alias* de tabla, en las columnas que se repitan
       entre las otras tablas que hacemos ~JOIN~

     #+BEGIN_QUOTE
     Una *clave compuesta* está formada por 2 o más atributos
     que identifican de manera unívoca a la fila/registro de la Tabla/Entidad
     #+END_QUOTE

    *Observación:*
    En este ejemplo sólo usamos el alias ~i~ para la tabla *items*,
    en las columnas ~stock_num~, ~manu_code~ porque también estan
    en la tabla *products*

    #+BEGIN_SRC sql
      SELECT i.stock_num, i.manu_code, description, unit_code
             SUM(quantity * i.unit_price) total_producto -- columna calculada
        FROM items i
               INNER JOIN products p
               -- aca estaría la clave compuesta
               ON (i.stock_num=p.stock_num AND i.manu_code=p.manu_code)
        -- es necesario GROUP BY porque usamos SUM,
        -- que se clasifica como "función agregada"
       GROUP BY i.stock_num, i.manu_code, unit_code;
    #+END_SRC

**** Ejemplo 3 - Join con más de dos tablas
     #+BEGIN_SRC sql
       SELECT i.stock_num, i.cod_proveedor, descripcion
              SUM(i.precio_unitario*cantidad) precio_total
         FROM items i
                INNER JOIN productos p
                    ON (i.stock_num=p.stock_num AND i.cod_proveedor=p.cod_proveedor)
                INNER JOIN unidades u
                    ON (p.cod_unidad=u.cod_unidad)
        GROUP BY i.stock_num, i.cod_proveedor, descripcion;
     #+END_SRC
**** Ejemplo 4 - Join con más de dos tablas
     #+BEGIN_SRC sql
       SELECT c.cliente_cod, nombre, apellido,
              p.pedido_cod, pedido_fecha,
              item_num, i.stock_num, i.proveedor_cod, proveedor_nombre,
              pt.descripcion, item_num, cantidad, i.precio
         FROM pedidos p
                JOIN clientes c       ON (p.cliente_cod=c.cliente_cod)
                JOIN items i          ON (p.pedido_cod=i.pedido_cod)
                JOIN producto_tipo pt ON (i.stock_num=pt.stock_num)
                JOIN proveedor p      ON (i.proveedor_cod=p.proveedor_cod)
                WHERE proveedor_nombre='nvidia' AND YEAR(pedido_fecha)=2010;
     #+END_SRC
*** Outer JOIN
**** Conceptos
     Mostrará todas las filas de la *Tabla Dominante* macheen o nó
     con la otra tabla
**** Outer LEFT
     La tabla de la izquierda será la *tabla dominante*

     #+BEGIN_SRC sql
       SELECT c.cliente_cod, apellido, nombre,
              COUNT(pedido_cod) cantidad_ordenes -- campo calculado
         FROM clientes c
                -- la tabla dominante será "clientes"
                -- mostrará todos los clientes, tengan o no un pedido
                -- y los que si tengan un pedido, lo asociará en la fila
                LEFT JOIN pedidos p ON (c.cliente_cod=p.cliente_cod)
         -- es necesario usar el "GROUP BY"
         -- porque usamos "COUNT" que se considera una "funcion agregada"
        GROUP BY c.cliente_cod, apellido, nombre;
     #+END_SRC
**** Outer RIGHT
     La tabla de la derecha será la *tabla dominante*
**** Outer FULL
     Ambas tablas serán *tablas dominantes*
*** Join Autoreferenciado
    Cuando hacemos referencia a la misma tabla
    
    #+BEGIN_SRC sql
      SELECT c2.nombre+', '+c2.apellido Padrino,
             c1.nombre+'. '+c1.apellido Referido
        FROM clientes c1
               JOIN clientes c2
               ON (c1.cod_del_referido=c2.cod_cliente)
    #+END_SRC
*** JOIN Columnas Ambiguas
    + Cuando un *atributo* existe en más de una tabla del ~SELECT~
      es necesario identificar de que Tabla lo tomaremos
    + Para especificar de que tabla ó ~alias~ es un atributo 
       usamos *DOT NOTATION*

    *Observación:*
    - Usar un ~alias~ de tabla, acorta el nombre/identificador de la tabla

    #+BEGIN_QUOTE
    *DOT NOTATION* es una notación para acceder a miembros de un
    objeto ó estructura

    En C lo usabamos para acceder a los miembros de un ~struct~

    En SQL lo usamos para acceder a los atributos de una ~tabla~
    y evitar la *ambiguedad* en caso de que una columna se repita
    en ambas tablas

    Algo es *ambiguo* si puede tener distintas *interpretaciones*
    (En el paradigma de objetos, la herencia simple lo evita)

    Algo es *redundante* si es *repetitivo*
    #+END_QUOTE
* Producto cartesiano
  + NO se recomienda su uso
  + Es una operación MUY COSTOSA para el *motor de base de datos*
  + En caso de usarlo se recomienda
    * *Proyectar* sólo las columnas que necesitemos
    * Acotar el dominio con la clásula ~WHERE~
  
  #+BEGIN_SRC sql
    SELECT * FROM orders, customer, items
  #+END_SRC
* Transacción
* Mecanismos para garantizar consistencia de datos
** Transacciones
*** Conceptos
  + Es un *conjunto de sentencias SQL* que se ejecutan *atómicamente*
  + Es un *mecanismo* que *asegura la consistencia de los datos*
  + Permite controlar que una operación completa se ejecute ó falle
    (impidiendo que queden datos inconsistentes)
*** BEGIN TRANSACTION
    Es la sentencia que precede a un conjunto de instrucciones
*** COMMIT TRANSACTION
    + Para actualizar los datos
    + Se utiliza *en caso de finalizar correctamente* la operación
    + Después de un ~COMMIT TRANSACTION~ NO se puede 
       deshacer la transacción con ~ROLLBACK TRANSACTION~ 
       se deben deshacer los cambios a mano...
*** ROLLBLACK TRANSACTION
    + Para deshacer la transacción (sólo si NO se hizo ~COMMIT~)
    + Se utiliza *en caso de fallar* la operación
*** [TODO] Ejemplo 1
** [TODO] Save Tran
*** Conceptos
    + Permite establecer puntos intermedios de guardado de información
    + Se puede realizar más de un ~SAVE TRAN~ en cada *transacción*
*** [TODO] Ejemplo 1
** [TODO] Transacciones Anidadas
*** [TODO] Ejemplo 1
** Singleton Transaction
   Cada sentencia de alteración de datos es un *SINGLETON TRANSACTION*
   (Como el ~INSERT~ ó ~UPDATE~ ó ~DELETE~ ) 
** Logs transaccionales
   - Es un registro con la información de cada operación
* Mecanismos de recuperación
** Recovery
*** Conceptos
   + Se ejecuta de forma automática al iniciar el motor de DB
   + Es un *método de recuperación* ante caídas
   + Se utiliza como *dispositivo de tolerancia a fallas*
   + Lleva al motor al punto consistente más reciente (*checkpoint*)

   #+BEGIN_QUOTE
   *Checkpoint* es el punto en el que el motor sincronizó 
   memoria y disco
   #+END_QUOTE
*** Como lo hace
   Utiliza los *logs transaccionales* para llevar a un estado consistente
   + realizando ~ROLLING FOWARDS~ de las transacciones exitosas
     (utilizando el *checkpoint* más reciente)
   + realizando ~ROLLING BACK~ de las transacciones fallidas
* Propiedades de un RDBMS
  - foco en la ejecución de *transacciones*
    + Atomicidad
    + Consistencia
    + Isolation (aislamiento)
    + Durabilidad
