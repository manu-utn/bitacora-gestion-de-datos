#+TITLE: Clase 07 - Triggers
* Conceptos
  - Ante un evento determinado se ejecute una sentencia sql de forma automatica
  - Es codigo transact-sql (NO es procedural)
  - se ejecuta cuando ocurre un evento (delete,insert,..)
  - es fundamental definir
    1. sobre que evento objeto (tablas, vistas)
    2. el momento (before, after)
    3. el tipo de evento (update, delete, insert)
* Trigger Inserted
  cuando es una operacion insert o update
* Trigger Deleted
  para operaciones delete y update
* Cuando se ejecuta
  - after instead of
* Porque usarlos
* Triggers posibles
** dml en tablas o views
   insert on tabla_nombre
   delete from tabla_nombre
** ddl en db (oracle, sql server)
   create, alter, drop
* Operaciones
  Se puede tener un log de los eventos, para saber que operaciones se hicieron
  (Ej. como auditoria para controlar al personal)
   
  + *logon* (si alguien se logea)
  + *logoff*
  + *startup*
  + *shutdown*
* Transacciones entre evento y accion
  se pueden combinar los triggers con las transacciones
* Momentos de ejecucion
** Before
   se ejecuta antes
** After
   es lo que sucede normalmente en sql
** for each row
** Instead of
   reemplaza
* Triggers
 - sys.triggers (solo para triggers)
 - sys.objects
 - sys...
* Ejemplos
** Ejemplo 1
  #+BEGIN_SRC sql
    create trigger actualizarAuditoria
    on nombre_tabla
    after update
    BEGIN INSERT INTO state_upd
    select state from inserted
    END
    -- falta  codigo

    DROP TRIGGER actualizarAuditoria

    SELECT * FROM SYS.TRIGGERS

    -- muestra todos los objetos de la base de datos
    SELECT * FROM SYS.OBJECTS


    SELECT * FROM SYS.OBJECTS where OBJECT_ID=numero

    -- muestra la metadata del objeto
    SELECT * FROM SYS.ALL_SQL_MODULES where OBJECT_ID=numero
  #+END_SRC
** Ejemplo 2
  #+BEGIN_SRC sql
    -- si queremos agregar una columna en la tabla orders
    ALTER TABLE orders ADD total DECIMAL(12,2);

    -- 1. creamos una tabla temporal (?)
    SELECT order_num, SUM (quantity*precio) totalItems
    into #ordenes
    FROM items GROUP BY order_num;

    -- 2. modificaos todos los registros, la columna total
    -- en base a la tabla temporal
    UPDATE orders o
    SET total=(SELECT totalitems FROM #ordenes o2
	 WHERE orders.order_num=o2.order_num)

    -- 3. trigger
  #+END_SRC
* Parte practica
 #+BEGIN_SRC sql
   USE stores7new;

   /** Ejecicio 1 **/
   CREATE TABLE Products_historia_precios(
   Stock_historia_Id int IDENTITY(1,1,) PRIMARY KEY,
   stock_num smallint,
   manu_code char(3),
   fechaHora datetime,
   usuario varchar(20),
   unit_price_old decimal(6,2),
   unit_price_new decimal(6,2),
   estado char DEFAULT 'A' CHECK(estado IN ('A', 'I'))
   );

   -- borramos por si ya estaba
   DROP TRIGGER cambio_precios_TR;
   -- creamos trigger en la tabla products
   CREATE TRIGGER cambio_precios_TR ON products
   -- cuando ocurra un update
   AFTER UPDATE AS
   BEGIN
   -- insertamos multiples registros
   -- hacemos INSERT nombre_tabla (campo1, campo2) SELECT (campo1, campo2) FROM 
   INSERT INTO Products_historia_precios
    (stock_num, manu_code, unit_price_old, unit_price_new, fechaHora, usuario)
    SELECT i.stock_num, i.manu_code, d.unit_price, i.unit_price, getdate(), current_user
    -- la tabla donde se hizo el INSERT
    FROM inserted i JOIN deleted d
    ON i.stock_num = d.stock_num AND i.manu_code = d.manu_code
   END

   -- hacemos un cambio para que se ejecute
   UPDATE products SET unit_price = 400
   WHERE stock_num = 1 AND manu_code = 'HRO';
   -- chequeamos si el trigger se ejecuto
   SELECT * FROM Products_historia_precios;


   /** Ejecicio 2**/
   -- Creamos un trigger captura el delete
   CREATE TRIGGER delete_stock_histoia ON products_historia_precios
   INSTEAD OF DELETE AS
   BEGIN
	   DECLARE @stock_historia_id int
	   -- declaramos el cursor
	   DECLARE stock_historia_borrado CURSOR FOR
		   SELECT stock_historia_id FROM deleted
		
	   -- abrimos el cursor, para poder leerlo
	   OPEN stock_historia_borrado
	
	   -- lee la primera fila
	   FETCH NEXT FROM stock_historia_borrado
	     INTO @stock_historia_id --

	   -- si no llego al final del cursor
	   -- cuando no haya mas registros se detiene
	   WHILE @@FETCH_STATUS = 0 
	   BEGIN
		   UPDATE products_historia_precios
		   SET estado = 'I' WHERE stock_historia_id = @stock_historia_id

		   -- chequeamos si hubo otro registro borrado
		   FETCH NEXT FROM stock_historia_borrado 
		     INTO @stock_historia_id -- y guardo el historia_id
	   END 
	   CLOSE stock_historia_borrado -- cerramos el cursor
	   -- borra el cursor en la zona de memoria
	   DEALLOCATE stock_historia_borrado --
   END;
	
 #+END_SRC

