#+TITLE: Clase 04 y 05 - Indices + Clusters + Query Plan

* Objetivo
  - Crear una *estructura de datos* adicional a la tabla (genera un espacio extra)
  - Ordena los datos en función a una *clave*
  - Se guardan los datos de manera secuencial
* Conceptos
 - Tener índices, NO quiere decir que los datos estén ordenados
   (/lo están pero por las claves de los indices/)
 - Por lo general los archivos se guardan de forma secuencial
 - Es otra estructura, para acceder más rapido a los datos (/similar a un acceso directo/)
 - Para no tener que evaluar dato por dato de manera secuencial
* [DOING] Conceptos anteriores aplicados al Btree y Clusters
** Niveles y Grado
  NO olvidar que la cantidad total de elementos de un árbol es ~(grado_arbol^cant_niveles)-1~
  - el *grado* la cant. max. nodos-hijos que puede tener cada nodo-padre
  - la cant. de *niveles ó pisos* es la cant. de accesos que tendré a disco (sea lectura/escritura)
  Por tanto a mayor grado => mayor es la cant. de nodos por nivel

  #+BEGIN_QUOTE
  un árbol binario (grado=2) con 3 niveles, puede tener hasta ~(2^3)-1 = 7~ => 7 nodos
  un arbol ternario (grado=3) con 3 niveles, puede tener hasta ~(3^3)-1 = 26~ => 26 nodos

  el grado por defecto de btree es de 200 => tendrá 200 nodos c/u con 200 claves (osea 200 filas)
  si tenemos un Btree con 3 pisos/niveles => ~200^3 = 40.000*200 = 8.000.000~ el árbol tendrá 8 millones de accesos
  #+END_QUOTE
** Inserción elementos - Estabilidad
   Cuando se insertan elementos en el *arbol b* (btree) que tienen misma *clave* 
   entra el concepto de *estabilidad* de los *métodos de clasificación*.
   Donde al insertar un elemento en un *nodo hoja* que ya contiene otro con misma clave,
   usará este concepto, respetando el orden original, e insertando el nuevo elemento 
   luego del que ya estaba.

  - *Orden Estable* => Si se mantiene el *orden relativo* original para registros con misma *clave*
  - *Orden Estable* => Si dos elementos con igual clave mantienen el mismo orden que al principio
* [DOING] Cluster
** Conceptos
  - Suelen tener un tamaño de ~4 (K)ilobytes~ (4.000 Bytes)
  - Es la menor unidad de medida de información para lectura/escritura en *Disco*
  - Significa como un *conjunto de elementos*
  - su tamaño depende del disco
  - dentro de un *cluster* puede haber *fragmentación interna*
    (/si se escribe información mas chica que el cluster, quedandole espacio libre/)
  - si se graba información en tamaño del *cluster* => NO hay *fragmentación interna*
    (/sucede en los sistemas operativos de Mainframe/)
** Relación Fragmentación Interna con los nodos y clusters
*** Tamaño del cluster
   Si el cluster es muy grande => habrá fragmentación interna
   (/Ej. si en el cluster escribimos "carlos" veremos lo sig. ~CARLOSXXXX~ donde cada ~X~ es espacio libre)
*** Tamaño de los nodos y tamaño de la clave
   1. Si tenemos *nodos* muy chicos (pocas filas/elementos) => habrá *fragmentación interna*
      (xq voy a generar nodos de más para completar el cluster)
   2. Si tenemos *nodos* con _clave muy grande_ => tendrá que hacer _más lecturas+lento_
*** Tamaño clave del nodo y cluster
   Si  tienen igual tamaño el *cluster* y la *Clave* del nodo hoja => NO habrá *fragmentación interna* (o será mínima) 
   - el *Cluster* es minima unidad lectura/escritura de información en disco
   - la *Clave* es valor del *nodo hoja* del *Btree* (de la tabla de indices del árbol b)
** Conceptos relacionados
*** Unidad de medida en MP y Disco
    - El *byte* es la menor medida de información y asignación en *Memoria RAM (MP)*
      (/siendo 1 byte equivalente a 8 bits/)
    - las computadoras usan como alfabeto el *ascii* (cada caracter ocupa 1 byte)
    - En *cluster* es la menor medida de información y asignación en *Disco*
*** UNidades
    - 1 (B)yte = 8 bits
    - 1 (K)ilobyte = 1000 (B)ytes
* [TODO] Query plan (Execution plan)
** Conceptos
   - es como el motor va a planificar el acceso a los datos (para resolver las queries, Ej. un select)
   - el "como" es si hizo
     - full index
     - partial index
     - ó secuencial
   - busca el "como acceder" y  "la mejor forma de acceder" a los datos
   - es el metodo que utiliza el motor de base de datos

  #+BEGIN_QUOTE
  Ej. si hacemos un ~SELECT * FROM clientes WHERE codCliente=100~
  es un acceso directo

  Ej. si hacemos un ~select nombre FROM clientes~
  el acceso es full index, si la columna "nombre" de la tabla clientes tenia un indice,

  Ej. si hacemos un ~SELECT nombre from clientes where edad<20~
  el acceso es *partial index* porque
  1. una parte la hace como *full index* (suponiendo que la columna nombre de esa tabla tiene indice)
  2. la otra la hace de forma *secuencial* porque busco uno por uno (suponiendo que no hay un indice en 
     la columa ~edad~)

  Ej. si hacemos un ~SELECT nombre from clientes where edad<20~
  el acceso es *full index*, si ambas columnas ~nombre~ y ~edad~ tienen cada una un *indice de acceso*
  (porque se cargaron en memoria)
  #+END_QUOTE
** Partial index
   cuando para hacer una busqueda una parte la hizo
   - con índice (full index)
   - otra con busqueda secuencial
** Full index
   accedió sin hacer una busqueda secuencial (hizo un acceso directo)
* Evaluacion Sql Vs Lenguaje C
  - el motor evalua de der. a izq
  - lenguaje c evalua de izq a der.
* Tipos de Acceso (Secuencial / Indexado / Directo)
** Secuencial
   - Es recorrer un conjunto de datos uno atrás del otro 1,2,3...
   - Los índices evitaran esto, porque es lento
** Secuencial Indexado
   - En función a alguna *clave*
   - Recorrer secuencialmente los indices
** Directo o Aleatorio
   - Acceder directamente a una posición, sin hacer una búsqueda
   - Acceder de forma directa a una *clave*, sin pasar por los elementos anteriores
     (/Ej. cuando usamos fseek en C, para acceder a una parte específica/)
** [DOING] Ejemplo en SQL
   Si hacés la sig. query "traeme al alumno codigo 101 y todas sus materias aprobadas"
   1. La primera parte es un *acceso directo* porque le indica específicamente que alumno
   2. La segunda parte es una *búsqueda secuencial indexada* porque debe lee materia por materia
* Arbol M-Ario (Arbol Multicamino)
** Conceptos
   - Un árbol es m-ario si todos sus nodos tienen al menos ~m~ nodos hijos
   - Tienen un *grado* mayor ó igual a un *árbol binario* (/si m=2 es un árbol binario/)
   - Mayor cant. de elementos => menos *niveles* => la busqueda es más rápido

   *Observaciones:*
   - Un árbol m-ario no necesariamente es *completo* (puede haber un nodo que no tiene grado ~m~)
   - Un árbol m-ario no necesariamente es *balanceado* (un sub-árbol con más peso que otro, cant. de nodos hijos)
** Propiedades
   - Un árbol m-ario es completo si.. cada nodo interno tiene grado=m
   - Un árbol m-ario de altura ~h~ puede tener un máximo de ~m^ĥ~ hojas
** Ejemplos
*** Ejemplo 1 - Arbol Binario Completo
    Un árbol m-ario con ~m=2~ es un *árbol binario*
    En este ejemplo tenemos un árbol donde cada *vértice interno* tiene grado 2
    osea un máximo de 2 nodos hijos. Esto incluye al *nodo raíz*

    *Observación:*
    Podemos ver que los nodos ~d~ y ~c~ no tienen grado 2, y está bien que así sea.
    Porque son *nodos hojas*, la condición de que un árbol m-ario es completo si sólo
    si los nodos son de grado=m, es para los *nodos internos* que no son *nodos hojas*

    #+BEGIN_SRC plantuml :file img/arbol-binario.png :exports results
      @startuml
      title Arbol m-ario m=2 (Arbol Binario)
      'left to right direction
      top to bottom direction

      (a) --> (b)
      (a) --> (c)

      (b) --> (d)
      (b) --> (e)

      (e) --> (f)
      (e) --> (g)
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/arbol-binario.png]]

*** Ejemplo 2 - Arbol Ternario Completo
    Un árbol m-ario con ~m=3~ es un *árbol tenario*
    En este ejemplo tenemos un árbol donde cada *vértice interno* tiene grado 3
    osea un máximo de 3 nodos hijos. Esto incluye al *nodo raíz* (/que es (a)/)

    #+BEGIN_SRC plantuml :file img/arbol-ternario.png :exports results
      @startuml
      title Arbol m-ario m=3 (Arbol Ternario)
      'left to right direction
      top to bottom direction

      (a) --> (b)
      (a) --> (c)
      (a) --> (d)

      (c) --> (k)
      (c) --> (m)
      (c) --> (n)

      (b) --> (e)
      (b) --> (f)
      (b) --> (g)

      (e) --> (h)
      (e) --> (i)
      (e) --> (j)
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/arbol-ternario.png]]

*** Ejemplo 3 - Arbol m-ario pero NO completo
    En este ejemplo tenemos un árbol m-ario de grado 3, 
    pero que NO es completo, porque el *nodo interno* ~b~ tiene *grado 2* en vez de 3

    #+BEGIN_SRC plantuml :file img/arbol-no-m-ario.png :exports results
      @startuml
      title Arbol m-ario (pero NO completo)
      'left to right direction
      top to bottom direction

      (b) #red

      (a) --> (b)
      (a) --> (c)
      (a) --> (d)

      (c) --> (k)
      (c) --> (m)
      (c) --> (n)

      (b) --> (e)
      (b) --> (g)

      (e) --> (h)
      (e) --> (i)
      (e) --> (j)
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/arbol-no-m-ario.png]]

* [TODO] Métodos para crear índices
** Conceptos
   Para crear *índices* en un (DBMS, Data Base Management System) se utiliza
   - Hashing
   - Arbol B (btree)

   *Observación:*
   - Un (DBMS) Data Base Management System, es un software que permite realizar
     - Operaciones (DML) Data Manipulation Language (select/update/delete)
     - Operaciones (DDL) Data Definition Language (create/alter/drop)
   - DML es un conjunto de operaciones para manipular los datos de una base de datos
   - DDL es un conjunto de operaciones para definir estructuras de datos para una base de datos
* Método Hashing
** Conceptos
  + Trabaja sobre una *tabla* y una *función hash* (función de dispersión)
  + Crea una estructura aparte, que es una *tabla* (vector de 2 dimensiones)
    - En la 1ra dimensión se colocan las *claves* (ordenadas)
    - En la 2da dimensión se colocan las *posiciones relativas*
      (en la tabla donde se encuentran los datos de esa clave)
  + En la tabla adiciona, mantiene las *claves* ordenadas
** Función Hash (ó de Dispersión)
*** Conceptos
    - Convierte un tipo de dato en un pequeño número entero (código hash)
    - Recibe como entrada la *clave* a almacenar
    - Devuelve la *posición* de la tabla en donde guardar la *clave*
    - A partir de un algoritmo genera un valor ó código hash
*** Cualidades
**** Evita Colisiones
     + Si devuelve un *conjunto de salida* diferente al *conjunto de entrada*
**** Distribuye las claves uniformemente
**** Facil de calcular
     + Si el *tiempo de ejecución* es ~O(1)~ (poca complejidad)
** Código Hash
   - Se utilizan como *indices* para las *tablas hash*
   - Sirven como *control de integridad* (para datos ó archivos)
** Colisiones
*** Conceptos
    - Cuando *función de hash* ante una *clave*, devuelve una *posición* ya ocupada en la tabla

    *Observación:*
    - La función de hash recibe como entrada una clave
    - La función de hash devuelve como valor una posición de donde se deberia
      de guardar la clave en la tabla
    - El valor de retorno calculado por la función de hash es el índice
      en donde se guardará un registro
** Técnicas de resolución de Colisiones
*** Encadenamiento
    + Cada celda del vector tiene una referencia a una *lista enlazada*
    + En las *listas enlazadas* se insertan los registros que colisionan en esa *posición*
*** Direccionamiento Abierto
**** Conceptos       
     - Se busca otra *posición* dentro de la tabla
**** Metodo - Sondeo lineal
     + Es el método más simple
     + Busca *secuencialmente* en la tabla, hasta encontrar una *posición* vacía
     + Si llega al final de la tabla => vuelve a la primera posición y retoma la búsqueda
**** Método - Sondeo Cuadrático
     + Busca una posición a una distancia específica, desde donde empieza el sondeo
     + Permite una mejor distribución de las claves *colisionadas*
     + Deriva de la fórmula ~F(i)=i^²~
     + Si se llega a una posición ocupada => cambia la fórmula del cálculo de la posición
       (de esta manera ~H+1^¹, H+2^², H+3^²,...,H+i^²~)
**** Método - Hashing Doble
    + Aplica la *función de hash* dos veces
    + La 2da *función de hash* (secundaria)
      - Debe ser distinta a la primaria
      - Usa el resultado como tamaño de salto (posible posición de la clave)
      - Si NO es mayor a cero => NO se produce el salto ó se produce un *bucle infinito*
* Método - Arbol B (Btree)
** Conceptos
   + Es un tipo de *árbol M-ario* su grado ronda entre los 200
   + Arma un arbol *completo* y *balanceado* (/Para cumplir con ~log(n)~ que/)
   + Tiene una *estructura vectorial* (si grado del arbol es 200, cada nodo tendrá [0,1,2,..,199] osea 200 hijos)
   + Crea *índices físicos* para el _acceso a la información_
   + Tiene dos tipos de *nodos* diferentes
     1. Un nodo hoja
     2. Un nodo rama

   *Observaciones:*
   + La (MP) Memoria Principal se considera 
     - un dispositivo de almacenamiento principal
     - de acceso rápido a los datos
     - con poco espacio de almacenamiento
   + El (HDD) Disco Duro se considera 
     - un dispositivo de almacenamiento secundario
     - de acceso LENTO a los datos
     - con mucho espacio de almacenamiento
     - los indices reducen el numero de accesos a disco
** Crecimiento
   - Se crea al reves de un árbol normal (no parte de la raíz)
     - Se parte de un *nodo hoja* que temporalmente actúa de nodo raíz
     - Cuando el árbol crece *nodo hoja* deja de ser raíz
   - El primer nodo que se crea es un *nodo hoja* porque
     - porque necesitamos guardar las *claves* y decir su *posición relativa* (de donde está)
     - si fuese un *nodo rama* el puntero NO tendría ningún *nodo hoja* donde apuntar
** Estructura Ordenada
   Para aumentar la velocidad de búsqueda tiene que haber un ordenamiento
   - _A nivel nodo_: los valores deben estar ordenados de menor a myor (por la clave)
   - _A nivel árbol_: los nodos deben apuntar a nodos con claves menores o iguales que él
** Ventajas y Desventajas
   Tiene como *ventajas*:
   + Minimiza las operaciones de entrada/salida a disco (dispositivo de almacenamiento secundario)

   Tiene como *desventajas*:
   + Es más lento que una *tabla de hashing* (/porque debe hacer búsqueda/)
** Condición de Balanceado
   - Garantiza que se realize en un tiempo ~O(logn)~ (orden de complejidad logarítmico)
     - la búsqueda
     - la inserción
     - la eliminación

   *Observaciones:*
   - Si el *orden de complejidad* es ~O(logn)~ => el algoritmo es eficiente (se realizará rápido)
   - El balanceado es una *característica* que puede tener o no un árbol
   - El *balanceado* de un árbol se puede *corregir* (reduciendo los niveles, y mejorando la velocidad de búsqueda)
   - Un árbol puede estar solo *balanceado* ó *perfectamente balanceado*
   - Un árbol está balanceado
     - si cada subarbol tiene la misma cant. de elementos (/es igual que decir que.. pesan lo mismo/)
     - ó si _hay una diferencia indivisible_ entre el *peso* de ambos subarboles y el grado del árbol
** Grado
   El grado ~M~ del árbol se determina en base
   - al tamaño de las *claves*
   - al tamaño de la *página del disco*

   *Observación:*
   - El grado de un árbol, es la _cant. máx. de hijos/subarboles que puede tener cada nodo_
** Nodo - Hoja
*** Conceptos
    - Es el primer nodo que se crea en un árbol *btree*
      (temporalmente actúa como raíz, cuando crece el árbol, deja de ser raíz)
    - Es un tanto similar a la *tabla de hashing*
    - Está formado por dos *componentes*
      1. Un componente de dato (la clave)
      2. Un componente puntero (posición relativa de la clave)

    #+name: btree-nodo-hoja
    |-------+----------|
    | Clave | Posición |
    |-------+----------|
    |   2   |    1     |
    |   3   |    5     |
    |   5   |    2     |
    |-------+----------|

    En la siguiente tabla vemos como el *componente puntero* que tiene {1,5,2} del nodo hoja
    actúa como puntero y nos lleva directo a esta otra tabla con más columnas, donde también
    tiene la *componente de dato* (la clave).

    |----------+-----+---------+------|
    | Posicion | ID  | Nombre  | Edad |
    |----------+-----+---------+------|
    |    0     | 10  | Carlos  |  15  |
    |   ~1~    | ~2~ | Mariano |  19  |
    |   ~2~    | ~5~ | Pepito  |  19  |
    |    3     |  8  | Samuel  |  17  |
    |    4     |  9  | Mariela |  18  |
    |   ~5~    | ~3~ | Sábato  |  99  |
    |----------+-----+---------+------|
*** Componente Dato
     - Tiene los valores de las *claves* (ordenados de menor a mayor)
*** Componente Puntero
    - Tiene la *posición relativa* de donde están los datos de la *clave* 
    - A diferencia de una *lista enlazada* este no apunta al siguiente elemento,
      sino a la *posición relativa*
    - A mayor el *grado* del árbol => mayor cant. de *componentes punteros*

    *Observación:*
    - El grado de un árbol, es la cant. max. de nodos hijos/subarboles que puede tener cada nodo
     (/Ej. Un árbol binario tiene grado 2, porque cada nodo puede tener o mas de 2 nodos hijos/)
** Nodo - Raiz/Rama
*** Conceptos
    - Puede apuntar a otro *nodo raíz* ó a un *nodo hoja*
    - También está formado por dos *componentes*
      1. Un componente de dato (valores de las *claves*)
      2. Un componente puntero (apunta a otro nodo, con claves menores o iguales a ella)

    #+name: btree-nodo-rama
    |-------+------|
    |  <c>  | <c>  |
    | Clave | Link |
    |-------+------|
    |   5   |  *   |
    |  50   |  *   |
    |-------+------|

    La primera fila del *nodo rama/raíz* apunta a este *nodo hoja*
    que contiene *claves* menores o iguales a ~5~

    #+name: btree-nodo-1
    |-------+------|
    |  <c>  | <c>  |
    | Clave | Link |
    |-------+------|
    |   2   |  1   |
    |   3   |  5   |
    |   5   |  2   |
    |-------+------|

    La segunda fila del *nodo rama/raíz* apunta a este *nodo hoja*
    que contiene *claves* menores o iguales a ~50~ (pero mayores a ~5~)

    #+name: btree-nodo-2
    |-------+------|
    | Clave | Link |
    |-------+------|
    |    15 |    0 |
    |    25 |    3 |
    |    50 |    4 |
    |-------+------|
*** Componente Dato
     - Tiene los valores de las *claves* (ordenados de menor a mayor)
*** Componente Puntero
    - Apunta a otro nodo, con *claves* menores o iguales a ella
** Ejemplo
   #+BEGIN_SRC plantuml :file img/btree-1.png :exports results
     @startuml
     'skinparam defaultTextAlignment center

     note as nodoRaiz
     <<Nodo Raiz>>
     |= Clave |= Link |
     | 5  |  * |
     | 50 |  * |
     end note


     note as nodoHojaIzq
     <<Nodo Hoja>>
     |= Clave |= Link |
     | 2 |  1 |
     | 3 |  5 |
     | 5 |  2 |
     end note

     note as nodoHojaDer
     <<Nodo Hoja>>
     |= Clave |= Link |
     | 15 |  3 |
     | 18 |  7 |
     | 50 |  4 |
     end note


     '================
     '==== NOTAS =====
     '================

     note as N1
     ,* Tiene elementos con __claves menor o igual que 50__
     ,* El **nodo raíz** accede directamente a este nodo
     ,* Dentro del nodo hace una **búsqueda secuencial**
     end note

     note as N2
     ,* Tiene elementos con __claves menor o igual que 5__
     ,* El **nodo raíz** accede directamente a este nodo
     ,* Dentro del nodo hace una **búsqueda secuencial**
     end note


     note as N3 #lightgreen
     ,* El **nodo hoja** tendrá tantos elementos/filas
       como claves que tenga.
     ,* Si tiene grado 50 => tendrá 50 elementos
     end note

     note as N4
     ,* Esta estructura contiene claves de las hojas
       (para acceder más rápido a los elementos)
     ,* El árbol sólo tiene 6 claves {2,3,5,15,18,50}
     ,* Dentro del nodo hace una **búsqueda secuencial**
       cuando encuentra la clave **accede directamente**
       al nodo que apuntado
     end note

     '================
     '== RELACIONES ==
     '================

     nodoRaiz -down-> nodoHojaDer : acceso directo
     nodoRaiz -down-> nodoHojaIzq : acceso directo

     N1      .up.  nodoHojaDer
     N2      .up.   nodoHojaIzq
     N4      .right. nodoRaiz

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:img/btree-1.png]]
* Arbol B - Búsqueda/Inserción/Eliminación
** Búsqueda
   - La *búsqueda* en un *árbol b* es similar al de un (ABB) *Arbol Binario de Búsqueda*
   - Se busca desde la *raíz* hacia las *hojas*
   - Se tienen *decisiones multicamino* en base al número de hijos del nodo

   *Obsevaciones:*
   - Si hay camino => existe una trayectoria (sucesión de aristas) para llegar de 
     un extremo al otro (vértices unidos por un conjunto de aristas)
   - En un (ABB) *árbol binario de búsqueda* se tienen *decisiones binarias*
     (por ser de grado=2, max. cant de hijos/subarboles que puede tener cada nodo)
** Inserción
   - Ocurre el proceso [[Split Page]] cuando no hay espacio en un nodo hoja para insertar elementos
   - Aparece el concepto de [[Fill Factor]] (factor de ocupamiento)
   - Asumiendo que el elemento a insertar es ~x~ y no existe en el árbol aún
     1. Se comienza a buscar por la *raíz*
     2. Se llega hasta a un *nodo hoja* (si no encontrara el elemento ~x~)
     3. Se inserta el elemento ~x~ en ese nodo hoja

   *Observación:*
   Recorda el criterio de ordenamiento (a nivel nodo/arbol).. Parte de la raiz, pero el algoritmo evalúa el 
   valor de la clave del nodo para saber que camino tomar, es decir selecciona aquellos nodos donde la clave
   sea menor o igual al valor de la clave a insertar.
** Eliminación
   - Ocurre el proceso [[Fusión]] cuando al eliminar un *elemento*, un *nodo* queda vacío, este debe eliminarse.
     (/esto afecta a los nodos padres, porque este pierde una referencia donde apuntaba/)
   - Asumiendo que el elemento a insertar es ~x~ y existe en el árbol
     1. Se comienza a buscar por la *raíz*
     2. Se llega hasta a un *nodo hoja* donde esté
     3. Se elimina el elemento ~x~ de ese nodo hoja
** Split Page
*** Conceptos
    + *Split* significa separar/dividir
    + *Split page* es dividir/romper las páginas en otras dos del mismo tamaño (/páginas de memoria/)
    + Ocurre cuando se intenta *insertar* un elemento ~x~ en un *nodo hoja* que no tiene espacio (/en memoria/)
    + Divide al *nodo hoja* en otros dos *nodos hojas* de igual tamaño (/misma cant. de elementos/)
      - Cada nodo hoja tendrá la mitad de elementos (/se mantiene el orden de los elementos/)
      - Se reparten los elementos entre los nodos, según el valor de las *claves*
        - Un nodo tendrá los que tengan *claves* de mayor valor numérico 
        - Otro nodo tendrá los que tengan *claves* de menor valor numérico

      #+BEGIN_QUOTE
      Un primer acercamiento podría ser..
      Cuando hay muchas actualizaciones en un índice y necesitan de más espacio
      las páginas se rompen/dividen por la mitad y una parte de ella se traslada
      a una página de indice libre     
      #+END_QUOTE

      #+BEGIN_QUOTE
      Otro acercamiento similar seria..
      Cuando una fila es agregada a una página de índice que está llena,
      el motor de base de datos mueve aprox. la mitad de las filas a una 
      nueva página abriendole espacio a la nueva fila.
      #+END_QUOTE
*** Ventajas
    - Si se utiliza en combinación con *fill factor* 
*** Desventajas
    - Puede demorarse un tiempo en realizar
    - Es un proceso costoso a nivel de recursos de máquina
    - Puede causar *fragmentación* (aumentando las operaciones de I/O)
** Fragmentación
*** Conceptos
    Cuando se ejecutan instrucciones como ~INSERT~, ~UPDATE~, ~DELETE~ 
    se produce una *dispersión de los datos* (fragmentación)
*** Problema
    Cuando los *índices* tienen *páginas* que están ordenadas de manera lógica (por una PK)
    y no coinciden con el orden físico dentro del archivo de datos.
*** Solución 1 - Reconstrucción del Indice (Rebuild)
    - Elimina y crea nuevamente el índice (removiendo la fragmentación)
    - Se *compactan* las páginas según la configuración del *fill factor*
*** Solución 2 - Reorganización del Indice (Reorganize)
    - Requiere menos recursos del sistema
    - Realiza una *desfragmentación* _a nivel de hoja de la página_
    - Reorganiza a nivel físico las hojas, para que coincidan con el orden lógico de las páginas de los indices
    - También se *compactan* las páginas según la configuración del *fill factor*
** Algunos conceptos de SISOP
*** Compactación
    Cuando se desplazan los segmentos en memoria
    - Cuando se consolidan particiones (procesos en ejecución) separadas por huecos (particiones libres, por pocesos que finalizaron) en una patición
    - Soluciona el problema de la *fragmentación externa* (huecos entre particiones con procesos activos)

    *Observación:*
    Consolidar se refiere a unir, a que dos o más particiones se junten en una.
** [TODO] Fill Factor
*** Conceptos
    - Se lo conoce como *factor de ocupamiento*
    - Determina el _porcentaje de espacio libre a nivel de hoja_ de cada *página* que será llenada con datos
    - Reserva el espacio en cada página como espacio libre/disponible para la expansión de los indices
      a medida que se van agregando datos a la tabla
    - Su valor oscila entre 1 y 100
*** Ventajas
    - Permite optimizar los indices
    - Reduce la cantidad de [[Split Page]] (si es muy frecuente, baja el rendimiento del índice)
    - Evita que se produzca *fragmentación interna* (tema de sisop)

    *Observación:*
    - La fragmentación interna, es lo que le sobra a una partición de memoria, son espacios libres
      que NO se utilizan.
*** Ejemplo 1
    Si tenemos un índice con *fill factor* de 80 entonces
    - 80% del espacio será para el índice
    - 20% será espacio libre, queda reservado para el momento que se agreguen datos, y sean guardados ahi
*** Ejemplo 2 - Problemas con columnas IDENTITY
    Si la información que se inserta en la tabla siempre va al final de la misma,
    los espacios vacíos (fragmentación interna) nunca van a ser llenados.
    
    Si agregamos información con una columna tipo ~IDENTITY~ (incrementa con la inserción de registros)
    y esta columna es la *primary key* de la tabla, las filas del índice se agregarán siempre
    al final del índice.

    Por tanto si sabemos que se aumentarán el tamaño de las filas, se recomienda dejar un *fill factor*
    menor a 100, agregandole un espacio extra a cada pagina, minimizando la cantidad de *page splits*
    que ocurren por la expansión de la tabla de índice.
** Fusión
*** Conceptos
    + Se fusionan _nodos que estén al mismo nivel_
    + Cuando al eliminar un *elemento* de un *nodo hoja*, este _nodo queda vacío y se debe eliminar_
    + Al eliminar el *nodo hoja* se podria generar una baja de los *nodos* que le anteceden (nodos padres)
      - porque el arbol queda *desbalanceado* y al corregir el *balanceo* ocurre eso
      - porque se pierde la referencia a donde apuntaba el nodo padre (referencia del nodo eliminado)
*** Ejemplo 1 - Antes de eliminar nodo
    En este ejemplo si eliminamos algun nodo de nivel 2, el arbol queda desbalanceado.
    Al corregir el balanceo, se eliminan los nodos del nivel 1, para que todos los nodos
    tengan la mitad de elementos.

    #+BEGIN_SRC plantuml :file img/btree-fusion.png :exports results
      @startuml
      left to right direction
      title Arbol B - Eliminación de Nodo (antes de eliminarlo)

      note as nodoRaiz
      |= Clave |= Link |
      | 5  |  * |
      | 50 |  * |
      end note

      together {
      note as nodoHojaIzq
      |= Clave |= Link |
      | 5      |  *    |
      | 10     |  *    |
      end note

      note as nodoHoja1 #palegreen
      |= Clave |= Link |
      | 3      |  1    |
      | 5      |  2    |
      end note

      note as nodoHoja2
      |= Clave |= Link |
      | 7      |  5    |
      | 10     |  3    |
      end note
      }

      together {
      note as nodoHojaDer
      |= Clave |= Link |
      | 20     |  *    |
      | 50     |  *    |
      end note

      note as nodoHoja3
      |= Clave  |= Link |
      | 15      |  9    |
      | 20      |  7    |
      end note

      note as nodoHoja4
      |= Clave  |= Link |
      | 35      |  8    |
      | 50      |  0    |
      end note

      }

      nodoRaiz    --> nodoHojaIzq
      nodoHojaIzq --> nodoHoja1
      nodoHojaIzq --> nodoHoja2

      nodoRaiz    --> nodoHojaDer
      nodoHojaDer --> nodoHoja3
      nodoHojaDer --> nodoHoja4

      note right of nodoHoja1: claves menores o igual a 5\nsupongamos que lo eliminamos
      note right of nodoHoja2: claves menores o igual a 10

      note right of nodoHoja3: claves menores o igual a 20
      note right of nodoHoja4: claves menores o igual a 50
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/btree-fusion.png]]
*** Ejemplo 1 - Despues de eliminar el nodo
    Luego de eliminar uno de los nodos del nivel 2, al corregir el balanceo
    se tuvo que borrar los nodos del nivel 1.
    Es necesario corregir el balanceo para que la velocidad de busqueda/inserción/eliminación
    sea de ~O(logn)~ osea que el *orden de complejidad* del algoritmo rápido.

    #+BEGIN_SRC plantuml :file img/btree-fusion2.png :exports results
      @startuml
      left to right direction
      title Arbol B - Eliminación de Nodo (después de eliminarlo)

      note as nodoRaiz
      |= Clave |= Link |
      | 10  |  * |
      | 20  |  * |
      | 50 |  * |
      end note

      note as nodoHoja2
      |= Clave |= Link |
      | 7      |  5    |
      | 10     |  3    |
      end note

      note as nodoHoja3
      |= Clave  |= Link |
      | 15      |  9    |
      | 20      |  7    |
      end note

      note as nodoHoja4
      |= Clave  |= Link |
      | 35      |  8    |
      | 50      |  0    |
      end note

      nodoRaiz --> nodoHoja2
      nodoRaiz --> nodoHoja3
      nodoRaiz --> nodoHoja4

      note right of nodoHoja2: claves menores o igual a 10
      note right of nodoHoja3: claves menores o igual a 20
      note right of nodoHoja4: claves menores o igual a 50
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/btree-fusion2.png]]
* Preguntas resueltas
** Pregunta 1
   Pag. 9:
   La *función de hash* es ~O(1)~ quiere decir que su *orden de complejidad* es constante?

   *Respuesta:*
   No. Sólo hace una operación matemática y es inmediata, no tiene nivel de complejidad
   por eso es ~O(1)~
** Pregunta (2)
   Pag. 11:
   Cuando dice que la *función hash* guarda en una *posición relativa* quiere decir que se guarda en memoria?

   *Respuesta:*
   Es relativa en base a la primera posición, la 5ta posición está a una distancia 
   de 4 posiciones de la primera.
   Es relativa, porque es distante a un punto en particular.
** Pregunta (3)
   Pag. 16:
   Los indices con *Hashing*, cuando habla del *método Sondeo cuadrático*
   cuando menciona la ~H~, se refiere a una *secuencia de incrementos* ?
   (/Obs: en la ppt de métodos de clasificación también aparece, en la pag. 19/)

   *Respuesta:* Correcto
** [TODO] Duda 4
   Pag. 17:
   Porque en el *hashing doble* si este arroja un valor negativo haría un loop infinito?
   porque luego produciria numeros negativos tan grandes, y nunca llegaria a ser positivo?
** Pregunta (5)
   Pag. 19:
   El debe ser *balanceado* para hacer menos consultas por eso minimiza las operaciones?
   en que otra ppt lo decia?

   *Respuesta:*
   Debe ser balanceado y completo
** [TODO] Duda 2
   Pag. 27-35:
   Un *nodo hoja* puede también ser un *nodo raíz*? habiendo varios *nodos raíz*?
   ó es único y el primero que se genera?

   *Respuesta:*
   Al principio es un *nodo hoja* porque debe apuntar a una *posición relativa*
   luego muere y se convierte en un *nodo raiz*
** [TODO] Duda F (basada en la duda 2)
   Entonces pueden haber varios *nodos raíz* ?
   En un árbol hay sólo 1 nodo raíz, pero.. en el *btree*  el *nodo raiz* tiene una *componente puntero*
   que apunta a otro *nodo hoja* y.. si hay 2 nodos que tienen *componentes punteros* apuntando
   no son también *nodo raiz*?
   Un ejemplo es la pag. 32
* Referencias Web
  1. https://ccia.ugr.es/~jfv/ed1/tedi/cdrom/docs/tablash.html
  2. https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/
  3. https://www.guru99.com/what-is-dbms.html
  4. https://www.oscarblancarteblog.com/2014/08/22/estructura-de-datos-arboles/
  5. https://www.personal.kent.edu/~rmuhamma/Algorithms/algorithm.html
  6. https://runestone.academy/runestone/static/pythoned/Trees/RecorridosDeArboles.html
  7. https://www.displayr.com/what-is-a-decision-tree/
  8. https://www.displayr.com/how-is-splitting-decided-for-decision-trees/
  9. https://social.technet.microsoft.com/wiki/contents/articles/13801.como-especificar-el-fill-factor-en-un-indice-es-es.aspx
  10. https://social.technet.microsoft.com/wiki/contents/articles/13796.sql-server-fragmentacion-y-desfragmentacion-de-indices-es-es.aspx
  11. https://miblogtecnico.wordpress.com/tag/fill-factor/
  12. https://www.sqlshack.com/es/operaciones-de-indices-sql-server/

  https://www.guru99.com/b-tree-example.html
