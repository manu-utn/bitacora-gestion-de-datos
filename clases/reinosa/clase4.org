#+TITLE: Clase 04 y 05 - Indices + Clusters + Query Plan

* Objetivo
  - Crear una *estructura de datos* adicional a la tabla (/esto genera un espacio extra/)
  - Ordena los datos en función a una *clave*
  - Se guardan los datos de manera secuencial
  - El índice es un *componente físico* trata de acceder *fisicamente* a los datos
    (/NO ordenado lógicamente, sino el acceso físico/)

  #+BEGIN_QUOTE
  "chequear"
  Cuando se habla de un acceso lógico, se tiende hacer referencia *ordenar los datos*
  que es lo que implementa el ~ORDER BY~ a través de los *métodos de clasificación*
  (que son algoritmos para ordenamiento)
  #+END_QUOTE
* Conceptos
 - Tener índices, NO quiere decir que los datos estén ordenados
   (/lo están pero por las claves de los indices/)
 - Por lo general los archivos se guardan de forma secuencial
 - Es otra estructura, para acceder más rapido a los datos (/similar a un acceso directo/)
 - Evita evaluar los datos de manera secuencial (/Ej. evita leer dato por dato, si no acceder directamente/)
* [DOING] Conceptos anteriores aplicados al Btree y Clusters
** Niveles y Grado
  NO olvidar que la cantidad total de elementos de un árbol es ~(grado_arbol^cant_niveles)-1~
  - el *grado* la cant. max. nodos-hijos que puede tener cada nodo-padre
  - la cant. de *niveles ó pisos* es la cant. de accesos que tendré a disco (sea lectura/escritura)
  Por tanto a mayor grado => mayor es la cant. de nodos por nivel

  #+BEGIN_QUOTE
  un árbol binario (grado=2) con 3 niveles, puede tener hasta ~(2^3)-1 = 7~ => 7 nodos
  un arbol ternario (grado=3) con 3 niveles, puede tener hasta ~(3^3)-1 = 26~ => 26 nodos

  el grado por defecto de btree es de 200 => tendrá 200 nodos c/u con 200 claves (osea 200 filas)
  si tenemos un Btree con 3 pisos/niveles => ~200^3 = 40.000*200 = 8.000.000~ el árbol tendrá 8 millones de accesos
  #+END_QUOTE
** Inserción elementos - Estabilidad
   Cuando se insertan elementos en el *arbol b* (btree) que tienen misma *clave* 
   entra el concepto de *estabilidad* de los *métodos de clasificación*.
   Donde al insertar un elemento en un *nodo hoja* que ya contiene otro con misma clave,
   usará este concepto, respetando el orden original, e insertando el nuevo elemento 
   luego del que ya estaba.

  - *Orden Estable* => Si se mantiene el *orden relativo* original para registros con misma *clave*
  - *Orden Estable* => Si dos elementos con igual clave mantienen el mismo orden que al principio
* Conceptos relacionados de AyED
** Posición relativa - Desplazamiento
*** Conceptos
   - Un arreglo/vector es *autoreferencial* su identificador hace referencia a la posición de inicio del vector
   - El operador de dirección ~*~ seguido del identificador del vector (Ej. ~*ptr~) trae el valor
     del elemento que está en la primera posición
   - Cuando hacemos ~*(ptr+0)~ ó ~*(ptr+1)~ ó ~*(ptr+2)~ y nos estamos desplazando en las posiciones del vector,
     esas posiciones 0,1,2 son *relativas* a la posición de inicio, a que distancia están del inicio.
*** Ejemplo 1 - Vectores
   #+BEGIN_QUOTE
   0, 1, 2, 3, 4, ... las posiciones 1,2,3,.. son *posiciones relativas* a la *posicion de inicio*

   Cuando nos desplazamos sumando un valor N (Ej. ~puntero+N~) estas son *posiciones relativas al inicio* 
   porque están a una distancia ~N~ de la posición inicial ~puntero+0~

   ~ptr+0~ nos desplazamos 0 de la posición inicial, osea es lo mismo que no poner el cero

   ~ptr+1~ nos desplazamos 1 de la posición inicial, esa posición relativa está a una distancia de 1 del principio
   ~ptr+2~ nos desplazamos 2 unidades de la posición de inicio, estamos distantes del principio 2 unidades
   ~*(ptr+3)~ nos desplazamos 3 unidades de la posición inicial y obtenemos el valor del elemento
   #+END_QUOTE
*** Ejemplo 2 - Tabla de Indice y Tabla de Hash
    En las siguientes tablas vemos como la primera tabla guarda la *posición relativa* de un registro 
    que guarda los datos en otra tabla. Son posiciones *relativas al inicio* (1,2,3,...) son distantes de la posicion=0

    Observamos que en la primera tabla las posiciones relativas están en desorden, porque sólo se ordenan por la *clave*

    #+name: tabla-de-indices
    |-------+-------------------|
    | clave | posicion relativa |
    |-------+-------------------|
    |     1 |                 3 |
    |     2 |                 0 |
    |     3 |                 1 |
    |     4 |                 2 |
    |-------+-------------------|

    #+name: tabla
    |-------------------+----+---------+-----------|
    | posicion relativa | id | nombre  | apellido  |
    |-------------------+----+---------+-----------|
    |                 0 | 14 | carlos  | ramirez   |
    |                 1 | 19 | pedro   | fernandez |
    |                 2 |  5 | maria   | perez     |
    |                 3 |  2 | ernesto | perez     |
    |-------------------+----+---------+-----------|
* [DOING] Cluster
** Conceptos
  - Es la _menor unidad de medida de información_ para lectura/escritura en *Disco*
  - Suelen tener un tamaño de ~4 (K)ilobytes~ (4.000 Bytes)
  - Significa como un *conjunto de elementos*
  - su tamaño depende del disco
  - dentro de un *cluster* puede haber *fragmentación interna*
    (/si se escribe información mas chica que el cluster, quedandole espacio libre/)
  - si se graba información en tamaño del *cluster* => NO hay *fragmentación interna*
    (/sucede en los sistemas operativos de Mainframe/)

  #+BEGIN_QUOTE
  Supongamos que las *claves* tienen un tamaño de ~20 Bytes~
  si le sumamos el tamaño *puntero* de ~4 Bytes~
  y lo multiplicamos por el *grado* del árbol que suele ser ~200~ (/cada _nodo padre_ tiene hasta un max. de 200 _nodos hijos_./)

  ~(20 Bytes + 4 Bytes) * 200 = 4800 Bytes~ <-- cada nodo ocuparía más de 1 cluster (lo supera por 800 Bytes)

  Como un cluster equivale aprox. 4000 Bytes, y.. 4800 Bytes > 4000 Bytes
  por cada nodo deberiamos leer en 2 clusters.
  Leyendo una parte del nodo en el primer cluster, y la otra en el segundo cluster.
  y esto equivale a hacer 2 lecturas en disco
  #+END_QUOTE
** Relación Fragmentación Interna con los nodos y clusters
*** Tamaño del cluster
    Si el cluster es muy grande => habrá *fragmentación interna*
    (/Ej. si en el cluster escribimos "carlos" veremos lo sig. ~CARLOSXXXX~ donde cada ~X~ es espacio libre)
*** Tamaño de los nodos y tamaño de la clave
   1. Si tenemos *nodos* muy chicos (pocas filas/elementos) => habrá *fragmentación interna*
      (xq voy a generar nodos de más para completar el cluster)
   2. Si tenemos *nodos* con _clave muy grande_ => tendrá que hacer _más lecturas+lento_
*** Tamaño clave del nodo y cluster
   Si  tienen igual tamaño el *cluster* y la *Clave* del nodo hoja => NO habrá *fragmentación interna* (o será mínima) 
   - el *Cluster* es minima unidad lectura/escritura de información en disco
   - la *Clave* es valor del *nodo hoja* del *Btree* (de la tabla de indices del árbol b)
*** Ejemplo
    Supongamos que cada fila equivale a un cluster
    
    SAMUELXXXXXXXXXXXXXX <- SAMUEL = 6 Bytes, las X que le siguen que son 12, son espacio libre de 12 Bytes
    PEDROXXXXXXXXXXXXXXX <- PEDRO = 5 Bytes, las trece X equivalen a 13 Bytes
    NAHUELXXXXXXXXXXXXXX <- idem
** Conceptos relacionados
*** Unidad de medida en MP y Disco
    - El *cluster* es la _menor medida de información y asignación en_ *Disco*
    - El *byte* es la _menor medida de información y asignación_ en *Memoria RAM (MP)*
      (/siendo 1 byte equivalente a 8 bits/)
    - las computadoras usan el alfabeto *ascii* (cada caracter ocupa 1 byte)
*** UNidades
    - 1 (B)yte = 8 bits
    - 1 (K)ilobyte = 1000 (B)ytes
* [TODO] Query plan (Execution plan)
** Conceptos
   - es como el motor va a planificar el acceso a los datos (para resolver las queries, Ej. un select)
   - el "como" es si hizo
     - full index
     - partial index
     - ó secuencial
   - busca el "como acceder" y  "la mejor forma de acceder" a los datos
   - es el metodo que utiliza el motor de base de datos

  #+BEGIN_QUOTE
  Ej. si hacemos un ~SELECT * FROM clientes WHERE codCliente=100~
  es un acceso directo

  Ej. si hacemos un ~select nombre FROM clientes~
  el acceso es full index, si la columna "nombre" de la tabla clientes tenia un indice,

  Ej. si hacemos un ~SELECT nombre from clientes where edad<20~
  el acceso es *partial index* porque
  1. una parte la hace como *full index* (suponiendo que la columna nombre de esa tabla tiene indice)
  2. la otra la hace de forma *secuencial* porque busco uno por uno (suponiendo que no hay un indice en 
     la columa ~edad~)

  Ej. si hacemos un ~SELECT nombre from clientes where edad<20~
  el acceso es *full index*, si ambas columnas ~nombre~ y ~edad~ tienen cada una un *indice de acceso*
  (porque se cargaron en memoria)
  #+END_QUOTE
** Partial index
   cuando para hacer una busqueda una parte la hizo
   - con índice (full index)
   - otra con busqueda secuencial
** Full index
   accedió sin hacer una busqueda secuencial (hizo un *acceso directo*)
* Evaluacion Sql Vs Lenguaje C
  - el motor de sql evalua de izq. a derecha (Ej. declarmos la variable edad en SQL ~edad INTEGER,~)
  - lenguaje c evalua de derecha a izq. (Ej. En SQL la declaramos al revés ~int edad;~)

  Si probamos en lenguaje C las siguientes sentencias, y evaluamos de der. a izq. no arrojan error.

  #+BEGIN_SRC c
    // C evalúa de derecha a izquierda

    // 1. una variable 'a'
    // 2. que es una constante entera
    // (si trataramos de cambiar el valor de 'a' arrojaría error)
    int const a;

    // 1. una variable 'a'
    // 2. que es un entero constante
    // (podemos cambiar el valor de 'a', pero no la podemos castear a otro tipo)
    const int a;
  #+END_SRC
* Tipos de Acceso (Secuencial / Indexado / Directo)
** Secuencial
   - Es recorrer un conjunto de datos uno atrás del otro 1,2,3...
   - Los índices evitaran esto, porque es lento

   #+BEGIN_SRC sql
     -- Esto hará una búsqueda secuencial
     -- porque seguramente no se creó un índice por el campo/columna "edad"
     -- sobre la tabla 'alumnos'
     SELECT nombre
       FROM alumnos
      WHERE edad > 18;
   #+END_SRC
** Secuencial Indexado
   - En función a alguna *clave*
   - Recorrer secuencialmente los indices
   - Hace una búsqueda secuencial pero en el índice, es decir en las claves

   #+BEGIN_SRC sql
     -- Suponiendo que se creó un índice sobre la tabla "alumnos" sobre el campo/columna "legajo"
     -- entonces hará una búsqueda secuencial indexada (porque lo hará en la tabla del índice)
     SELECT nombre
       FROM alumnos
      WHERE legajo > 1034522;
   #+END_SRC
** Directo o Aleatorio
   - Acceder directamente a una posición, sin hacer una búsqueda
   - Sucede siempre que haya una igualdad (/Ej. legajo=101019, dni=3512, producto_cod=10, .../)
   - Acceder de forma directa a una *clave*, sin pasar por los elementos anteriores
     (/Ej. cuando usamos ~fseek~ (fileSeek) en C, para acceder a una posición específica del archivo/)

   #+BEGIN_SRC sql
     -- Este es un acceso directo, porque indicamos que registro queremos
     SELECT nombre
       FROM alumnos
      WHERE legajo=1034522;
   #+END_SRC
** Ejemplos
*** Ejemplo 1 - fseek
    Cuando hacemos ~fseek(punteroArchivo, 10, SEEK_SET)~ nos ubicamos directamente en la posición=10
    porque nos desplazamos 10 bytes desde el inicio que es ~SEEK_SET~

    Si hacemos ~fseek(punteroArchivo, 0, SEEK_END)~ nos ubicamos directamente al final del archivo
    no colocamos el ~offset~ de desplazamiento, porque pusimos que se ubique al final de archivo
    con ~SEEK_END~
*** Ejemplo 2 - Código C con fseek
    #+BEGIN_SRC c
      #include <stdio.h>

      int main()
      {
        FILE *fp;
        fp = fopen("test1.txt", "r");

        // Movemos el puntero al final del archivo
        fseek(fp, 0, SEEK_END);

        // Imprimimos la posición en donde quedó el puntero
        // (será la cant. de caracteres que tiene el archivo)
        printf("%ld\n", ftell(fp));
        fclose(fp);

        //------------------------------------

        fp = fopen("test2.txt","w+");
        fputs("This is org mode", fp);

        // 1. Se ubica al principio de archivo con SEEK_SET
        // 2. Se desplaza 8 bytes desde la posición de inicio, offset=8
        // (reemplazará "org mode" por "emacs mode")
        fseek( fp, 8, SEEK_SET );
        fputs("emacs mode", fp);
        fclose(fp);

        //------------------------------------

        // la 'a' refiere a 'append' es decir agregar/insertar
        fp = fopen("test2.txt","a+");

        // 1. Se ubica al final del archivo con SEEK_END
        // 2. NO se desplaza ninguna posición offset=0
        // y agrega el texto "chau xd"
        fseek(fp, 0, SEEK_END);
        fputs("chau xd", fp);
        fclose(fp);

        return 0;
      }
    #+END_SRC
*** Ejemplo 3 - SQL - Busqueda secuencial indexada + Acceso Directo
    Si hacés la sig. query "traeme al alumno codigo 101 y todas sus materias aprobadas"
    1. La primera parte es un *acceso directo* porque le indica específicamente que alumno
    2. La segunda parte es una *búsqueda secuencial indexada* porque debe lee materia por materia

    #+BEGIN_SRC sql
      -- Esta podría ser una búsqueda secuencial indexada y de acceso directo
      SELECT nombre
        FROM alumnos a JOIN materias m a.legajo = m.legajo
       WHERE legajo=101 AND materia.estado='aprobada';
    #+END_SRC
* Cuando usar Constraint Identity
  - El ~constraint~ IDENTITY es valor autonumérico (genera valores númericos de forma incremental)
  - Se utiliza cuando no basta solo con la PK identificar unívocamente a un registro

  #+BEGIN_QUOTE
  Supongamos que un Supermercado un cliente compra 4 unidades del mismo producto,
  entonces para generar la *Factura* (ticket) la PK ~cod_producto~ no es suficiente
  para identificar cada unidad por separado. Además.. que lanzaría un error,
  porque NO puede haber en la factura, dos registros con misma PK

  Podemos crear un Identity que identifique unívocamente cada renglón de la *Factura*
  para diferenciar cada unidad comprada del mismo producto.
  #+END_QUOTE
* Arbol M-Ario (Arbol Multicamino)
** Conceptos
   - Un árbol es m-ario si todos sus nodos tienen al menos ~m~ nodos hijos
   - Tienen un *grado* mayor ó igual a un *árbol binario* (/si m=2 es un árbol binario/)
   - Mayor cant. de elementos => menos *niveles* => la busqueda es más rápida

   *Observaciones:*
   - Un árbol m-ario no necesariamente es *completo* (puede haber un nodo que no tiene grado ~m~)
   - Un árbol m-ario no necesariamente es *balanceado* (un sub-árbol con más peso que otro, cant. de nodos hijos)
** Propiedades
   - Un árbol m-ario es completo si.. cada nodo interno tiene grado=m
   - Un árbol m-ario de altura ~h~ puede tener un máximo de ~m^ĥ~ hojas
** Ejemplos
*** Ejemplo 1 - Arbol Binario Completo
    Un árbol m-ario con ~m=2~ es un *árbol binario*
    En este ejemplo tenemos un árbol donde cada *vértice interno* tiene grado 2
    osea un máximo de 2 nodos hijos. Esto incluye al *nodo raíz*

    *Observación:*
    Podemos ver que los nodos ~d~ y ~c~ no tienen grado 2, y está bien que así sea.
    Porque son *nodos hojas*, la condición de que un árbol m-ario es completo si sólo
    si los nodos son de grado=m, es para los *nodos internos* que no son *nodos hojas*

    #+BEGIN_SRC plantuml :file img/arbol-binario.png :exports results
      @startuml
      title Arbol m-ario m=2 (Arbol Binario)
      'left to right direction
      top to bottom direction

      (a) --> (b)
      (a) --> (c)

      (b) --> (d)
      (b) --> (e)

      (e) --> (f)
      (e) --> (g)
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/arbol-binario.png]]

*** Ejemplo 2 - Arbol Ternario Completo
    Un árbol m-ario con ~m=3~ es un *árbol tenario*
    En este ejemplo tenemos un árbol donde cada *vértice interno* tiene grado 3
    osea un máximo de 3 nodos hijos. Esto incluye al *nodo raíz* (/que es (a)/)

    #+BEGIN_SRC plantuml :file img/arbol-ternario.png :exports results
      @startuml
      title Arbol m-ario m=3 (Arbol Ternario)
      'left to right direction
      top to bottom direction

      (a) --> (b)
      (a) --> (c)
      (a) --> (d)

      (c) --> (k)
      (c) --> (m)
      (c) --> (n)

      (b) --> (e)
      (b) --> (f)
      (b) --> (g)

      (e) --> (h)
      (e) --> (i)
      (e) --> (j)
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/arbol-ternario.png]]

*** Ejemplo 3 - Arbol m-ario pero NO completo
    En este ejemplo tenemos un árbol m-ario de grado 3, 
    pero que NO es completo, porque el *nodo interno* ~b~ tiene *grado 2* en vez de 3

    #+BEGIN_SRC plantuml :file img/arbol-no-m-ario.png :exports results
      @startuml
      title Arbol m-ario (pero NO completo)
      'left to right direction
      top to bottom direction

      (b) #red

      (a) --> (b)
      (a) --> (c)
      (a) --> (d)

      (c) --> (k)
      (c) --> (m)
      (c) --> (n)

      (b) --> (e)
      (b) --> (g)

      (e) --> (h)
      (e) --> (i)
      (e) --> (j)
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/arbol-no-m-ario.png]]

* Métodos para crear índices
** Conceptos
   Para crear *índices* en un (DBMS, Data Base Management System) se utiliza
   + Tablas de Hashing
     - tienen una *estructura estática* (/es más rápida que una dinámica/)
     - se utilizan en minicomputadores/mainframes (/los recursos se asignan al inicio/)
   + Arbol B ó Btree
     - tienen una *estructura dinámica* (/es más lenta que una estática/)
     - se utilizan en pc (/los recursos se asignan en función de como se usan osea on-demand/)

   *Observación:*
     - Operaciones (DDL) Data Definition Language (create/alter/drop)
     - DML es un conjunto de operaciones para manipular los datos de una base de datos
     - DDL es un conjunto de operaciones para definir estructuras de datos para una base de datos
** Estructura-Distribución-Asignación (Estática/Dinámica)
*** Asignación Estática/Dinámica
    - Una asignación estática de los recursos es más rápida, porque ya los tiene preasignados al inicio
    - Una asignación dinámica es más lenta, porque se hace on-demand (a medida que se necesita)
*** Estructura Estática/Dinámica
    - Una estructura estática NO cambia (Ej. un disco con capacidad de 10gb, una ram de 4g, ...)
*** Mainframe Vs. PC
    + Los mainframes/minicomputadores
      - tienen una estructura estática (porque los recursos se asignan al principio, tiene una *asignación estática*)
      - los datos que se almacenan están sectorizados (se sabe donde se guardará)
      - buscar información en los mainframes es más rápido porque están sectorizados, se sabe donde están
    + Las PC
      - tienen una estructura estática (pero con una *distribución estática* se tiene una *asignación dinámica*)
      - los recursos se asignan on-demand, en función de como se usan
      - los datos se almacenan fragmentados (se guardan en distintas partes)
      - buscar información en las PC es más lento porque la información está fragmentada, y se guarda en distintas partes
*** Ejemplo 1
    - La PC tiene una *estructura estática* porque sus recursos ó componentes físicos son limitados
      (/Ej. Si tenemos un disco de 10GB éste no va a crecer más/)
    - Si la PC tiene *distribución estática* de los recursos se puede tener una *asignación dinámica*
** [TODO] Ejemplos
*** [TODO] Ejemplo 1 - Acceso al SIGA UTN
    - El acceso al SIGA es mediante el *número de legajo* del alumno
    - El número de legajo sería la  ~PK, Primary key~ porque identifica unívocamente a cada alumno
      (al menos en la regional)
    - Es conveniente crear un índice sobre ese campo, para acceder más rápido a los datos de los alumnos

    *Observaciones:*
    1. La tabla del índice es una estructura en MP, por eso su velocidad de acceso es mayor
       (/a diferencia del acceso a disco que es más lento, suponiendo que NO es un disco de estado sólido/)
    2. Cuando creamos un índice sobre un campo
       - La DB debe guardar los datos en dos estructuras (la del índice y la de los datos)
       - La velocidad de escritura es más lenta
       - La estructura de los datos está en disco
       - La estructura del índice está en MP
    3. Cuando creamos un índice, estamos creando una estructura adicional que contiene
       - la *clave* de la tabla del indice, campo por el cual está ordenado
       - la *posición relativa* a la tabla que contiene los datos (puede estar en desorden)
    
    #+BEGIN_SRC sql
      -- Supongamos que queremos obtener datos de los alumnos
      -- y la tabla NO tiene un índice sobre la columna 'legajo'
      -- que es la PK, Primary Key de la tabla..
      -- La consulta a la DB podría demorar 30 segundos ó más
      SELECT nombre, apellido FROM alumnos;

      -- Si creamos el índice sobre la PK, y repetimos la instrucción
      CREATE INDEX alumno_legajo
        ON alumnos (legajo);
      -- esta consulta podría demorar sólo 1 ó 2 segundos a lo mucho
      SELECT nombre, apellido FROM alumnos;
    #+END_SRC
* Método Hashing
** Conceptos
  + Trabaja sobre una *tabla* y una *función hash* (función de dispersión)
  + Crea una estructura aparte, que es una *tabla* (vector de 2 dimensiones)
    - En la 1ra dimensión se colocan las *claves* (ordenadas)
    - En la 2da dimensión se colocan las *posiciones relativas*
      (en la tabla donde se encuentran los datos de esa clave)
  + En la tabla adicional, mantiene las *claves* ordenadas  
** Función Hash (ó de Dispersión)
*** Conceptos
    - Convierte un tipo de dato en un pequeño número entero (código hash)
    - Recibe como entrada la *clave* a almacenar
    - Devuelve la *posición* de la tabla en donde guardar la *clave*
    - A partir de un algoritmo genera un valor ó código hash

    *Observación:*
    El motor de DB elige la *función de hash* según el *dominio de entrada*
*** Cualidades
**** Evita Colisiones
     + Si devuelve un *conjunto de salida* diferente al *conjunto de entrada*
       (/Ej. si se ingresa una clave, debe devolver una posicion relativa diferente/)
     + Con dominios diferentes es muy probable que exista colisión, por más buena
       que sea la función de hash
**** Distribuye las claves uniformemente
**** Fácil de calcular
     + Si el *tiempo de ejecución* es ~O(1)~ (poca complejidad)
** Dominios
*** Conceptos
*** Dominio de Entrada
    - Son las *claves* a almacenar
    - Es el valor que recibe la funcion de hash
    - Tiende a ser mayor que el dominio del vector donde se van a almacenar las claves

    #+BEGIN_QUOTE
    Supongamos que el dominio de entrada (de la Primary Key) son los Reales (Ej. char)
    y el dominio de donde se va a guardar es los Naturales...

    Para la conversión de Reales a Naturales dicho valor se debe *truncar*,
    y ahi es donde se pierde la efectividad
    #+END_QUOTE
*** Dominio de Salida
    - Son las *posiciones relativas* en donde se van a guardar esas *claves*
    - Es el retorno de la función de hash
    - Es un valor numérico entero (posición relativa)
** Código Hash
   - Se utilizan como *indices* para las *tablas hash*
   - Sirven como *control de integridad* (para datos ó archivos)
** Conceptos de AMI
   - Toda función tiene un *dominio* (entrada) y *codominio* (salida, en función del dominio)
   - Una función es *inversible* cuando se cumple que dominio=codominio
   - Para evitar *colisiones* la función debe ser *biyectiva* (ó inversible)
   - En general el *dominio de entrada* es mayor
** Colisiones
    - Cuando *función de hash* ante una *clave*, devuelve una *posición* ya ocupada en la tabla
    - Surje cuando para un mismo valor de entrada devuelve la misma posición

    *Observación:*
    - La función de hash recibe como entrada una clave
    - La función de hash devuelve como valor una posición de donde se deberia
      de guardar la clave en la tabla
    - El valor de retorno calculado por la función de hash es el índice
      en donde se guardará un registro
** Técnicas de resolución de Colisiones
*** Encadenamiento
**** Conceptos
      + Cada celda del vector tiene una referencia a una *lista enlazada*
      + En las *listas enlazadas* se insertan los registros que colisionan en esa *posición*
      + Crea una *estructura* adicional (las listas enlazadas)
**** Ventajas
     - El acceso es más directo
     - Mantiene el concepto de *secuencialidad indexada*
       (/sirve para acceso directo, mantiene un orden/)
**** Desventajas
     - Ocupa más espacio (/por la estructura adicional de lisas enlazadas/)
*** Direccionamiento Abierto
**** Conceptos       
     - Se busca otra *posición* dentro de la tabla
     - Evita agregar *estructuras* adicionales de encadenamiento
       (/esto aplica para los tres métodos/)
**** Metodo - Sondeo lineal
     + Es el método más simple, busca en pequeñas distancias
     + Busca *secuencialmente* en la tabla, hasta encontrar una *posición* vacía
     + Si llega al final de la tabla => vuelve a la primera posición y retoma la búsqueda
**** Método - Sondeo Cuadrático
     + Distribuye más los valores, busca con una distancia mayor
     + Busca una posición a una distancia específica, desde donde empieza el sondeo
     + Permite una mejor distribución de las claves *colisionadas*
     + Deriva de la fórmula ~F(i)=i^²~
     + Si se llega a una posición ocupada => cambia la fórmula del cálculo de la posición
       (de esta manera ~H+1^¹, H+2^², H+3^²,...,H+i^²~ donde la ~H~ es la posición
       y el ~i^²~ es el desvío
**** Método - Hashing Doble
    + Aplica la *función de hash* dos veces
    + La entrada sería la *posición* que devolvió la primera vez que se aplicó
    + La 2da *función de hash* (secundaria)
      - Debe ser distinta a la primaria
      - Usa el resultado como tamaño de salto (posible posición de la clave)
      - Si NO es mayor a cero => NO se produce el salto ó se produce un *bucle infinito*
**** Desventajas
     - No tiene *secuencialidad indexada*
**** Ventajas
     - No ocupa espacio extra, al no generar estructuras adicionales
* Método - Arbol B (Btree)
** Conceptos
   + Es un tipo de *árbol M-ario* su grado ronda entre 50 y 2000 pero su valor suele ser ~200~
   + Arma un arbol *completo* y *balanceado* (/Para cumplir con ~log(n)~./)
   + Tiene una *estructura vectorial* (/si grado del árbol es 200, cada nodo tendrá un vector [0,1,2,..,199] osea 200 hijos/)
   + Crea *índices físicos* para el _acceso a la información_
   + Según el tipo de árbol el primer nodo puede ser
     - _nodo raíz_ (/si es un árbol común/)
     - _nodo hoja_ y _nodo raíz_ (/Ej. se cumple si es un árbol-b, donde temporalmente es nodo raíz/)
   + Tiene dos tipos de *nodos* diferentes
     1. Un nodo hoja
     2. Un nodo rama

   *Observaciones:*
   + Toda búsqueda computacional es *secuencial* un árbol sólo reduce número de búsquedas
     - Cuanto mayor *grado* tenga el árbol => más elementos en menos niveles => se accede a los elementos con menos preguntas
       (/resulta de hacer ~grado^niveles - 1~ donde cada nivel sería cada piso del árbol/)
     - Si tiene un grado=2 (binario)  y tiene 3 niveles => tiene (2^³)-1 = 8-1  = 7 nodos en cada nivel
     - Si tiene un grado=3 (ternario) y tiene 3 niveles => tiene (3^³)-1 = 27-1 = 26 nodos por nivel
   + La _(MP) Memoria Principal_ se considera
     - un dispositivo de almacenamiento principal
     - de acceso rápido a los datos
     - con poco espacio de almacenamiento
   + El _(HDD) Disco Duro_ se considera 
     - un dispositivo de almacenamiento secundario
     - de acceso LENTO a los datos (/suponiendo que es _disco mecánico_, y no uno de _estado sólido_./)
   + con mucho espacio de almacenamiento
     - los indices reducen el numero de accesos a disco
** Crecimiento
   + Se crea al revés de un árbol normal (no parte de la raíz)
     - Se parte de un *nodo hoja* que temporalmente actúa de nodo raíz
     - Cuando el árbol crece *nodo hoja* deja de ser raíz
   + El primer nodo que se crea es un *nodo hoja* porque
     - porque necesitamos guardar las *claves* y decir su *posición relativa* (de donde está)
     - si fuese un *nodo rama* el puntero NO tendría ningún *nodo hoja* donde apuntar
** Estructura Ordenada
   Para aumentar la velocidad de búsqueda tiene que haber un ordenamiento
   + _A nivel nodo_: los valores deben estar ordenados de menor a mayor (por la clave)
   + _A nivel árbol_: los nodos deben apuntar a nodos con claves menores o iguales que él
** Ventajas y Desventajas
   Tiene como *ventajas*:
   + Minimiza las operaciones de entrada/salida a disco (dispositivo de almacenamiento secundario)

   Tiene como *desventajas*:
   + Es más lento que una *tabla de hashing* (/porque debe hacer búsqueda/)
** Condición de Balanceado
   - Garantiza que se realize en un tiempo ~O(logn)~ (orden de complejidad logarítmico)
     - la búsqueda
     - la inserción
     - la eliminación

   *Observaciones:*
   - Si el *orden de complejidad* es ~O(logn)~ => el algoritmo es eficiente (se realizará rápido)
   - El balanceado es una *característica* que puede tener o no un árbol
   - El *balanceado* de un árbol se puede *corregir* (reduciendo los niveles, y mejorando la velocidad de búsqueda)
   - Un árbol puede estar solo *balanceado* ó *perfectamente balanceado*
   - Un árbol está balanceado
     - si cada subarbol tiene la misma cant. de elementos (/es igual que decir que.. pesan lo mismo/)
     - ó si _hay una diferencia indivisible_ entre el *peso* de ambos subarboles y el grado del árbol
** Grado
   El grado ~M~ del árbol se determina en base
   - al tamaño de las *claves*
   - al tamaño de la *página del disco*

   *Observación:*
   - El grado de un árbol, es la _cant. máx. de hijos/subarboles que puede tener cada nodo_
** Nodo - Hoja
*** Conceptos
    - Es el primer nodo que se crea en un árbol *btree*
      (temporalmente actúa como raíz, cuando crece el árbol, deja de ser raíz)
    - Está formado por dos *componentes*
      1. Un componente de dato (la clave)
      2. Un componente puntero (posición relativa de la clave)

    *Observación:*
    - El _nodo hoja_ es equivalente a la *tabla de hashing* porque tiene las *claves* y una *posición relativa*
      de donde están los datos

    #+name: btree-nodo-hoja
    |-------+----------|
    | Clave | Posición |
    |-------+----------|
    |   2   |    1     |
    |   3   |    5     |
    |   5   |    2     |
    |-------+----------|

    En la siguiente tabla vemos como el *componente puntero* que tiene {1,5,2} del nodo hoja
    actúa como puntero y nos lleva directo a esta otra tabla con más columnas, donde también
    tiene la *componente de dato* (la clave).

    |----------+-----+---------+------|
    | Posicion | ID  | Nombre  | Edad |
    |----------+-----+---------+------|
    |    0     | 10  | Carlos  |  15  |
    |   ~1~    | ~2~ | Mariano |  19  |
    |   ~2~    | ~5~ | Pepito  |  19  |
    |    3     |  8  | Samuel  |  17  |
    |    4     |  9  | Mariela |  18  |
    |   ~5~    | ~3~ | Sábato  |  99  |
    |----------+-----+---------+------|
*** Componente Dato
     - Tiene los valores de las *claves* (ordenados de menor a mayor)
*** Componente Puntero
    - Tiene la *posición relativa* de donde están los datos de la *clave* 
    - A diferencia de una *lista enlazada* este no apunta al siguiente elemento,
      sino a la *posición relativa*
    - A mayor el *grado* del árbol => mayor cant. de *componentes punteros*

    *Observación:*
    - El grado de un árbol, es la cant. max. de nodos hijos/subarboles que puede tener cada nodo
     (/Ej. Un árbol binario tiene grado 2, porque cada nodo puede tener o mas de 2 nodos hijos/)
** Nodo - Raiz/Rama
*** Conceptos
    - Puede apuntar a otro *nodo raíz* ó a un *nodo hoja*
    - También está formado por dos *componentes*
      1. Un componente de dato (valores de las *claves*)
      2. Un componente puntero (apunta a otro nodo, con claves menores o iguales a ella)

    #+name: btree-nodo-rama
    |-------+------|
    | Clave | Link |
    |-------+------|
    |   5   |  *   |
    |  50   |  *   |
    |-------+------|

    La primera fila del *nodo rama/raíz* apunta a este *nodo hoja*
    que contiene *claves* menores o iguales a ~5~

    #+name: btree-nodo-1
    |-------+------|
    | Clave | Link |
    |-------+------|
    |   2   |  1   |
    |   3   |  5   |
    |   5   |  2   |
    |-------+------|

    La segunda fila del *nodo rama/raíz* apunta a este *nodo hoja*
    que contiene *claves* menores o iguales a ~50~ (pero mayores a ~5~)

    #+name: btree-nodo-2
    |-------+------|
    | Clave | Link |
    |-------+------|
    |    15 |    0 |
    |    25 |    3 |
    |    50 |    4 |
    |-------+------|
*** Componente Dato
     - Tiene los valores de las *claves* (ordenados de menor a mayor)
*** Componente Puntero
    - Apunta a otro nodo, con *claves* menores o iguales a ella
** Ejemplo
   #+BEGIN_SRC plantuml :file img/btree-1.png :exports results
     @startuml
     'skinparam defaultTextAlignment center

     note as nodoRaiz
     <<Nodo Raiz>>
     |= Clave |= Link |
     | 5  |  * |
     | 50 |  * |
     end note


     note as nodoHojaIzq
     <<Nodo Hoja>>
     |= Clave |= Link |
     | 2 |  1 |
     | 3 |  5 |
     | 5 |  2 |
     end note

     note as nodoHojaDer
     <<Nodo Hoja>>
     |= Clave |= Link |
     | 15 |  3 |
     | 18 |  7 |
     | 50 |  4 |
     end note


     '================
     '==== NOTAS =====
     '================

     note as N1
     ,* Tiene elementos con __claves menor o igual que 50__
     ,* El **nodo raíz** accede directamente a este nodo
     ,* Dentro del nodo hace una **búsqueda secuencial**
     end note

     note as N2
     ,* Tiene elementos con __claves menor o igual que 5__
     ,* El **nodo raíz** accede directamente a este nodo
     ,* Dentro del nodo hace una **búsqueda secuencial**
     end note


     note as N3 #lightgreen
     ,* El **nodo hoja** tendrá tantos elementos/filas
       como claves que tenga.
     ,* Si tiene grado 50 => tendrá 50 elementos
     end note

     note as N4
     ,* Esta estructura contiene claves de las hojas
       (para acceder más rápido a los elementos)
     ,* El árbol sólo tiene 6 claves {2,3,5,15,18,50}
     ,* Dentro del nodo hace una **búsqueda secuencial**
       cuando encuentra la clave **accede directamente**
       al nodo que apuntado
     end note

     '================
     '== RELACIONES ==
     '================

     nodoRaiz -down-> nodoHojaDer : acceso directo
     nodoRaiz -down-> nodoHojaIzq : acceso directo

     N1      .up.  nodoHojaDer
     N2      .up.   nodoHojaIzq
     N4      .right. nodoRaiz

     @enduml
   #+END_SRC

   #+RESULTS:
   [[file:img/btree-1.png]]
* Arbol B - Búsqueda/Inserción/Eliminación
** Búsqueda
   - La búsqueda dentro del árbol y de los nodos es *secuencial*
     (/Cuando encuentra la clave, usa el valor de _componente puntero_ para ir a un _nodo hoja_ ó a la _posición relativa_./)
   - La *búsqueda* en un *árbol b* es similar al de un (ABB) *Arbol Binario de Búsqueda*
   - Se busca desde la *raíz* hacia las *hojas*
   - Se tienen *decisiones multicamino* en base al número de hijos del nodo

   *Obsevaciones:*
   - Si hay camino => existe una trayectoria (sucesión de aristas) para llegar de 
     un extremo al otro (vértices unidos por un conjunto de aristas)
   - En un (ABB) *árbol binario de búsqueda* se tienen *decisiones binarias*
     (por ser de grado=2, max. cant de hijos/subarboles que puede tener cada nodo)
   - El único que tiene un _acceso directo_ natural es el *hashing*
** Inserción
   - Ocurre el proceso [[Split Page]] cuando no hay espacio en un nodo hoja para insertar elementos
   - Aparece el concepto de [[Fill Factor]] (factor de ocupamiento)
   - Asumiendo que el elemento a insertar es ~x~ y no existe en el árbol aún
     1. Se comienza a buscar por la *raíz*
     2. Se llega hasta a un *nodo hoja* (si no encontrara el elemento ~x~)
     3. Se inserta el elemento ~x~ en ese nodo hoja

   *Observación:*
   Recorda el criterio de ordenamiento (a nivel nodo/arbol).. Parte de la raiz, pero el algoritmo evalúa el 
   valor de la clave del nodo para saber que camino tomar, es decir selecciona aquellos nodos donde la clave
   sea menor o igual al valor de la clave a insertar.
** Eliminación
   - Ocurre el proceso [[Fusión]] cuando al eliminar un *elemento*, un *nodo* queda vacío, este debe eliminarse.
     (/esto afecta a los nodos padres, porque este pierde una referencia donde apuntaba/)
   - Asumiendo que el elemento a insertar es ~x~ y existe en el árbol
     1. Se comienza a buscar por la *raíz*
     2. Se llega hasta a un *nodo hoja* donde esté
     3. Se elimina el elemento ~x~ de ese nodo hoja
** Split Page
*** Conceptos
    + *Split* significa separar/dividir
    + *Split page* es dividir/romper las páginas en otras dos del mismo tamaño (/páginas de memoria/)
    + Pueden ocurrir 1 o varios _split page_ según el tamaño del árbol
    + Ocurre cuando se intenta *insertar* un elemento ~x~ en un *nodo hoja* que no tiene espacio (/en memoria/)
    + Divide al *nodo hoja* en otros dos *nodos hojas* de igual tamaño (/misma cant. de elementos/)
      - Cada nodo hoja tendrá la mitad de elementos (/se mantiene el orden de los elementos/)
      - Se reparten los elementos entre los nodos, según el valor de las *claves*
        - Un nodo tendrá los que tengan *claves* de mayor valor numérico 
        - Otro nodo tendrá los que tengan *claves* de menor valor numérico

      #+BEGIN_QUOTE
      Un primer acercamiento podría ser..
      Cuando hay muchas actualizaciones en un índice y necesitan de más espacio
      las páginas se rompen/dividen por la mitad y una parte de ella se traslada
      a una página de indice libre     
      #+END_QUOTE

      #+BEGIN_QUOTE
      Otro acercamiento similar seria..
      Cuando una fila es agregada a una página de índice que está llena,
      el motor de base de datos mueve aprox. la mitad de las filas a una 
      nueva página abriendole espacio a la nueva fila.
      #+END_QUOTE
*** Ventajas
    - Si se utiliza en combinación con *fill factor* 
*** Desventajas
    - Puede demorarse un tiempo en realizar
    - Es un proceso costoso a nivel de recursos de máquina
    - Puede causar *fragmentación* (aumentando las operaciones de I/O)
** Fragmentación
*** Conceptos
    Cuando se ejecutan instrucciones como ~INSERT~, ~UPDATE~, ~DELETE~ 
    se produce una *dispersión de los datos* (fragmentación)
*** Problema
    Cuando los *índices* tienen *páginas* que están ordenadas de manera lógica (por una PK)
    y no coinciden con el orden físico dentro del archivo de datos.
*** Solución 1 - Reconstrucción del Indice (Rebuild)
    - Elimina y crea nuevamente el índice (removiendo la fragmentación)
    - Se *compactan* las páginas según la configuración del *fill factor*
*** Solución 2 - Reorganización del Indice (Reorganize)
    - Requiere menos recursos del sistema
    - Realiza una *desfragmentación* _a nivel de hoja de la página_
    - Reorganiza a nivel físico las hojas, para que coincidan con el orden lógico de las páginas de los indices
    - También se *compactan* las páginas según la configuración del *fill factor*
** Conceptos de SISOP
*** Compactación
    Cuando se desplazan los segmentos en memoria
    - Cuando se consolidan particiones (procesos en ejecución) separadas por huecos (particiones libres, por pocesos que finalizaron) en una patición
    - Soluciona el problema de la *fragmentación externa* (huecos entre particiones con procesos activos)

    *Observación:*
    Consolidar se refiere a unir, a que dos o más particiones se junten en una.
** [TODO] Fill Factor
*** Conceptos
    - Se lo conoce como *factor de ocupamiento*
    - Determina el _porcentaje de espacio libre a nivel de hoja_ de cada *página* que será llenada con datos
    - Reserva el espacio en cada página como espacio libre/disponible para la expansión de los indices
      a medida que se van agregando datos a la tabla
    - Su valor oscila entre 1 y 100
*** Ventajas
    - Permite optimizar los indices
    - Reduce la cantidad de [[Split Page]] (si es muy frecuente, baja el rendimiento del índice)
    - Evita que se produzca *fragmentación interna* (tema de sisop)

    *Observación:*
    - La fragmentación interna, es lo que le sobra a una partición de memoria, son espacios libres
      que NO se utilizan.
*** Ejemplo 1
    Si tenemos un índice con *fill factor* de 80 entonces
    - 80% del espacio será para el índice
    - 20% será espacio libre, queda reservado para el momento que se agreguen datos, y sean guardados ahi
*** Ejemplo 2 - Problemas con columnas IDENTITY
    Si la información que se inserta en la tabla siempre va al final de la misma,
    los espacios vacíos (fragmentación interna) nunca van a ser llenados.
    
    Si agregamos información con una columna tipo ~IDENTITY~ (incrementa con la inserción de registros)
    y esta columna es la *primary key* de la tabla, las filas del índice se agregarán siempre
    al final del índice.

    Por tanto si sabemos que se aumentarán el tamaño de las filas, se recomienda dejar un *fill factor*
    menor a 100, agregandole un espacio extra a cada pagina, minimizando la cantidad de *page splits*
    que ocurren por la expansión de la tabla de índice.
** Fusión
*** Conceptos
    + Se fusionan _nodos que estén al mismo nivel_
    + Cuando al eliminar un *elemento* de un *nodo hoja*, este _nodo queda vacío y se debe eliminar_
    + Al eliminar el *nodo hoja* se podria generar una baja de los *nodos* que le anteceden (nodos padres)
      - porque el arbol queda *desbalanceado* y al corregir el *balanceo* ocurre eso
      - porque se pierde la referencia a donde apuntaba el nodo padre (referencia del nodo eliminado)
*** Ejemplo 1 - Antes de eliminar nodo
    En este ejemplo si eliminamos algun nodo de nivel 2, el arbol queda desbalanceado.
    Al corregir el balanceo, se eliminan los nodos del nivel 1, para que todos los nodos
    tengan la mitad de elementos.

    #+BEGIN_SRC plantuml :file img/btree-fusion.png :exports results
      @startuml
      left to right direction
      title Arbol B - Eliminación de Nodo (antes de eliminarlo)

      note as nodoRaiz
      |= Clave |= Link |
      | 5  |  * |
      | 50 |  * |
      end note

      together {
      note as nodoHojaIzq
      |= Clave |= Link |
      | 5      |  *    |
      | 10     |  *    |
      end note

      note as nodoHoja1 #palegreen
      |= Clave |= Link |
      | 3      |  1    |
      | 5      |  2    |
      end note

      note as nodoHoja2
      |= Clave |= Link |
      | 7      |  5    |
      | 10     |  3    |
      end note
      }

      together {
      note as nodoHojaDer
      |= Clave |= Link |
      | 20     |  *    |
      | 50     |  *    |
      end note

      note as nodoHoja3
      |= Clave  |= Link |
      | 15      |  9    |
      | 20      |  7    |
      end note

      note as nodoHoja4
      |= Clave  |= Link |
      | 35      |  8    |
      | 50      |  0    |
      end note

      }

      nodoRaiz    --> nodoHojaIzq
      nodoHojaIzq --> nodoHoja1
      nodoHojaIzq --> nodoHoja2

      nodoRaiz    --> nodoHojaDer
      nodoHojaDer --> nodoHoja3
      nodoHojaDer --> nodoHoja4

      note right of nodoHoja1: claves menores o igual a 5\nsupongamos que lo eliminamos
      note right of nodoHoja2: claves menores o igual a 10

      note right of nodoHoja3: claves menores o igual a 20
      note right of nodoHoja4: claves menores o igual a 50
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/btree-fusion.png]]
*** Ejemplo 1 - Despues de eliminar el nodo
    Luego de eliminar uno de los nodos del nivel 2, al corregir el balanceo
    se tuvo que borrar los nodos del nivel 1.
    Es necesario corregir el balanceo para que la velocidad de busqueda/inserción/eliminación
    sea de ~O(logn)~ osea que el *orden de complejidad* del algoritmo rápido.

    #+BEGIN_SRC plantuml :file img/btree-fusion2.png :exports results
      @startuml
      left to right direction
      title Arbol B - Eliminación de Nodo (después de eliminarlo)

      note as nodoRaiz
      |= Clave |= Link |
      | 10  |  * |
      | 20  |  * |
      | 50 |  * |
      end note

      note as nodoHoja2
      |= Clave |= Link |
      | 7      |  5    |
      | 10     |  3    |
      end note

      note as nodoHoja3
      |= Clave  |= Link |
      | 15      |  9    |
      | 20      |  7    |
      end note

      note as nodoHoja4
      |= Clave  |= Link |
      | 35      |  8    |
      | 50      |  0    |
      end note

      nodoRaiz --> nodoHoja2
      nodoRaiz --> nodoHoja3
      nodoRaiz --> nodoHoja4

      note right of nodoHoja2: claves menores o igual a 10
      note right of nodoHoja3: claves menores o igual a 20
      note right of nodoHoja4: claves menores o igual a 50
      @enduml
    #+END_SRC

    #+RESULTS:
    [[file:img/btree-fusion2.png]]
* Preguntas resueltas
** Pregunta 1
   Pag. 9:
   La *función de hash* es ~O(1)~ quiere decir que su *orden de complejidad* es constante?

   *Respuesta:*
   No. Sólo hace una operación matemática y es inmediata, no tiene nivel de complejidad
   por eso es ~O(1)~
** Pregunta (2)
   Pag. 11:
   Cuando dice que la *función hash* guarda en una *posición relativa* quiere decir que se guarda en memoria?

   *Respuesta:*
   Es relativa en base a la primera posición, la 5ta posición está a una distancia 
   de 4 posiciones de la primera.
   Es relativa, porque es distante a un punto en particular.
** Pregunta (3)
   Pag. 16:
   Los indices con *Hashing*, cuando habla del *método Sondeo cuadrático*
   cuando menciona la ~H~, se refiere a una *secuencia de incrementos* ?
   (/Obs: en la ppt de métodos de clasificación también aparece, en la pag. 19/)

   *Respuesta:* Correcto
** [TODO] Duda 4
   Pag. 17:
   Porque en el *hashing doble* si este arroja un valor negativo haría un loop infinito?
   porque luego produciria numeros negativos tan grandes, y nunca llegaria a ser positivo?
** Pregunta (5)
   Pag. 19:
   El debe ser *balanceado* para hacer menos consultas por eso minimiza las operaciones?
   en que otra ppt lo decia?

   *Respuesta:*
   Debe ser balanceado y completo
** [TODO] Duda 2
   Pag. 27-35:
   Un *nodo hoja* puede también ser un *nodo raíz*? habiendo varios *nodos raíz*?
   ó es único y el primero que se genera?

   *Respuesta:*
   Al principio es un *nodo hoja* porque debe apuntar a una *posición relativa*
   luego muere y se convierte en un *nodo raiz*
** [TODO] Duda F (basada en la duda 2)
   Entonces pueden haber varios *nodos raíz* ?
   En un árbol hay sólo 1 nodo raíz, pero.. en el *btree*  el *nodo raiz* tiene una *componente puntero*
   que apunta a otro *nodo hoja* y.. si hay 2 nodos que tienen *componentes punteros* apuntando
   no son también *nodo raiz*?
   Un ejemplo es la pag. 32
* Referencias Web
  1. https://ccia.ugr.es/~jfv/ed1/tedi/cdrom/docs/tablash.html
  2. https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/
  3. https://www.guru99.com/what-is-dbms.html
  4. https://www.oscarblancarteblog.com/2014/08/22/estructura-de-datos-arboles/
  5. https://www.personal.kent.edu/~rmuhamma/Algorithms/algorithm.html
  6. https://runestone.academy/runestone/static/pythoned/Trees/RecorridosDeArboles.html
  7. https://www.displayr.com/what-is-a-decision-tree/
  8. https://www.displayr.com/how-is-splitting-decided-for-decision-trees/
  9. https://social.technet.microsoft.com/wiki/contents/articles/13801.como-especificar-el-fill-factor-en-un-indice-es-es.aspx
  10. https://social.technet.microsoft.com/wiki/contents/articles/13796.sql-server-fragmentacion-y-desfragmentacion-de-indices-es-es.aspx
  11. https://miblogtecnico.wordpress.com/tag/fill-factor/
  12. https://www.sqlshack.com/es/operaciones-de-indices-sql-server/

  https://www.guru99.com/b-tree-example.html
